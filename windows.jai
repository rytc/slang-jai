//
// This file was auto-generated using the following command:
//
// jai generate.jai
//

// Slang Result helpers and macro-defined constants

SLANG_FAILED :: (status: s32) -> bool {
    return status < 0;
}

SLANG_SUCCEEDED :: (status: s32) -> bool {
    return status >= 0;
}

SLANG_GET_RESULT_FACILITY :: (r: s32) -> s32 {
    return (r >> 16) & 0x7fff;
}

SLANG_GET_RESULT_CODE :: (r: s32) -> s32 {
    return r & 0xffff;
}

SLANG_MAKE_ERROR :: (fac: s32, code: s32) -> s32 {
    return (fac << 16) | code | cast(s32, 0x80000000);
}

SLANG_MAKE_SUCCESS :: (fac: s32, code: s32) -> s32 {
    return (fac << 16) | cast(s32, code);
}

SLANG_FAIL :: #run SLANG_MAKE_ERROR(SLANG_FACILITY_WIN_GENERAL, 0x4005);

SLANG_MAKE_WIN_GENERAL_ERROR :: (code: s32) -> s32 {
    return SLANG_MAKE_ERROR(SLANG_FACILITY_WIN_GENERAL, code);
}

SLANG_E_NOT_IMPLEMENTED :: #run SLANG_MAKE_WIN_GENERAL_ERROR(0x4001);
SLANG_E_NO_INTERFACE    :: #run SLANG_MAKE_WIN_GENERAL_ERROR(0x4002);
SLANG_E_ABORT           :: #run SLANG_MAKE_WIN_GENERAL_ERROR(0x4004);

SLANG_E_INVALID_HANDLE :: #run SLANG_MAKE_ERROR(SLANG_FACILITY_WIN_API, 6);
SLANG_E_INVALID_ARG    :: #run SLANG_MAKE_ERROR(SLANG_FACILITY_WIN_API, 0x57);
SLANG_E_OUT_OF_MEMORY  :: #run SLANG_MAKE_ERROR(SLANG_FACILITY_WIN_API, 0xe);

SLANG_MAKE_CORE_ERROR :: (code: s32) -> s32 {
    return SLANG_MAKE_ERROR(SLANG_FACILITY_CORE, code);
}

SLANG_E_BUFFER_TOO_SMALL :: #run SLANG_MAKE_CORE_ERROR(1);
SLANG_E_UNINITIALIZED    :: #run SLANG_MAKE_CORE_ERROR(2);
SLANG_E_PENDING          :: #run SLANG_MAKE_CORE_ERROR(3);
SLANG_E_CANNOT_OPEN      :: #run SLANG_MAKE_CORE_ERROR(4);
SLANG_E_NOT_FOUND        :: #run SLANG_MAKE_CORE_ERROR(5);
SLANG_E_INTERNAL_FAIL    :: #run SLANG_MAKE_CORE_ERROR(6);
SLANG_E_NOT_AVAILABLE    :: #run SLANG_MAKE_CORE_ERROR(7);
SLANG_E_TIME_OUT         :: #run SLANG_MAKE_CORE_ERROR(8);



SLANG_VC :: 14;

SLANG_CLANG :: 0;

SLANG_SNC :: 0;

SLANG_GHS :: 0;

SLANG_GCC :: 0;

SLANG_WIN64 :: 1;

SLANG_WINRT :: 0;

SLANG_XBOXONE :: 0;

SLANG_X360 :: 0;

SLANG_WIN32 :: 0;

SLANG_ANDROID :: 0;

SLANG_LINUX :: 0;

SLANG_IOS :: 0;

SLANG_OSX :: 0;

SLANG_PS3 :: 0;

SLANG_PS4 :: 0;

SLANG_PSP2 :: 0;

SLANG_WIIU :: 0;

SLANG_GCC_FAMILY :: SLANG_CLANG || SLANG_SNC || SLANG_GHS || SLANG_GCC;
SLANG_WINDOWS_FAMILY :: SLANG_WINRT || SLANG_WIN32 || SLANG_WIN64;
SLANG_MICROSOFT_FAMILY :: SLANG_XBOXONE || SLANG_X360 || SLANG_WINDOWS_FAMILY;
SLANG_LINUX_FAMILY :: SLANG_LINUX || SLANG_ANDROID;
SLANG_APPLE_FAMILY :: SLANG_IOS || SLANG_OSX;
SLANG_UNIX_FAMILY :: SLANG_LINUX_FAMILY || SLANG_APPLE_FAMILY;

SLANG_ENABLE_DXVK :: 0;
SLANG_ENABLE_VKD3D :: 0;

SLANG_ENABLE_DIRECTX :: 1;
SLANG_ENABLE_DXGI_DEBUG :: 1;
SLANG_ENABLE_DXBC_SUPPORT :: 1;
SLANG_ENABLE_PIX :: 1;

SLANG_HAS_EXCEPTIONS :: 1;

SLANG_HAS_MOVE_SEMANTICS :: 1;

SLANG_HAS_ENUM_CLASS :: 1;

SLANG_PROCESSOR_X86_64 :: 1;

SLANG_PROCESSOR_ARM :: 0;

SLANG_PROCESSOR_ARM_64 :: 0;

SLANG_PROCESSOR_X86 :: 0;

SLANG_PROCESSOR_POWER_PC :: 0;

SLANG_PROCESSOR_POWER_PC_64 :: 0;

SLANG_PROCESSOR_FAMILY_X86 :: SLANG_PROCESSOR_X86_64 | SLANG_PROCESSOR_X86;
SLANG_PROCESSOR_FAMILY_ARM :: SLANG_PROCESSOR_ARM | SLANG_PROCESSOR_ARM_64;
SLANG_PROCESSOR_FAMILY_POWER_PC :: SLANG_PROCESSOR_POWER_PC_64 | SLANG_PROCESSOR_POWER_PC;

SLANG_PTR_IS_64 :: SLANG_PROCESSOR_ARM_64 | SLANG_PROCESSOR_X86_64 | SLANG_PROCESSOR_POWER_PC_64;

SLANG_PTR_IS_32 :: SLANG_PTR_IS_64 ^ 1;

SLANG_LITTLE_ENDIAN :: 1;
SLANG_UNALIGNED_ACCESS :: 1;

SLANG_BIG_ENDIAN :: 0;

SLANG_FACILITY_WIN_GENERAL :: 0;
SLANG_FACILITY_WIN_INTERFACE :: 4;
SLANG_FACILITY_WIN_API :: 7;

SLANG_FACILITY_BASE :: 0x200;

SLANG_FACILITY_CORE :: SLANG_FACILITY_BASE;

SLANG_FACILITY_INTERNAL :: SLANG_FACILITY_BASE + 1;

SLANG_FACILITY_EXTERNAL_BASE :: 0x210;

SLANG_OK :: 0;

SLANG_UNBOUNDED_SIZE :: 18446744073709551615;

SLANG_API_VERSION :: 0;

/*!
@mainpage Introduction

API Reference: slang.h

@file slang.h
*/
SlangUInt32 :: u32;
SlangInt32 :: s32;

SlangInt :: s64;
SlangUInt :: u64;

SlangSSizeT :: s64;
SlangSizeT :: u64;

SlangBool :: bool;

/*!
@brief Severity of a diagnostic generated by the compiler.
Values come from the enum below, with higher values representing more severe
conditions, and all values >= SLANG_SEVERITY_ERROR indicating compilation
failure.
*/
SlangSeverityIntegral :: s32;
SlangSeverity :: enum SlangSeverityIntegral {
    DISABLED :: 0;
    NOTE     :: 1;
    WARNING  :: 2;
    ERROR    :: 3;
    FATAL    :: 4;
    INTERNAL :: 5;

    SLANG_SEVERITY_DISABLED :: DISABLED;
    SLANG_SEVERITY_NOTE     :: NOTE;
    SLANG_SEVERITY_WARNING  :: WARNING;
    SLANG_SEVERITY_ERROR    :: ERROR;
    SLANG_SEVERITY_FATAL    :: FATAL;
    SLANG_SEVERITY_INTERNAL :: INTERNAL;
}

SlangDiagnosticFlags :: s32;
SLANG_DIAGNOSTIC_FLAG :: enum s32 {
    VERBOSE_PATHS            :: 1;
    TREAT_WARNINGS_AS_ERRORS :: 2;

    SLANG_DIAGNOSTIC_FLAG_VERBOSE_PATHS            :: VERBOSE_PATHS;
    SLANG_DIAGNOSTIC_FLAG_TREAT_WARNINGS_AS_ERRORS :: TREAT_WARNINGS_AS_ERRORS;
}

SlangBindableResourceIntegral :: s32;
SlangBindableResourceType :: enum SlangBindableResourceIntegral {
    NON_BINDABLE   :: 0;
    TEXTURE        :: 1;
    SAMPLER        :: 2;
    UNIFORM_BUFFER :: 3;
    STORAGE_BUFFER :: 4;

    SLANG_NON_BINDABLE   :: NON_BINDABLE;
    SLANG_TEXTURE        :: TEXTURE;
    SLANG_SAMPLER        :: SAMPLER;
    SLANG_UNIFORM_BUFFER :: UNIFORM_BUFFER;
    SLANG_STORAGE_BUFFER :: STORAGE_BUFFER;
}

/* NOTE! To keep binary compatibility care is needed with this enum!

* To add value, only add at the bottom (before COUNT_OF)
* To remove a value, add _DEPRECATED as a suffix, but leave in the list

This will make the enum values stable, and compatible with libraries that might not use the
latest enum values.
*/
SlangCompileTargetIntegral :: s32;
SlangCompileTarget :: enum SlangCompileTargetIntegral {
    TARGET_UNKNOWN                  :: 0;
    TARGET_NONE                     :: 1;
    GLSL                            :: 2;
    GLSL_VULKAN_DEPRECATED          :: 3;
    GLSL_VULKAN_ONE_DESC_DEPRECATED :: 4;
    HLSL                            :: 5;
    SPIRV                           :: 6;
    SPIRV_ASM                       :: 7;
    DXBC                            :: 8;
    DXBC_ASM                        :: 9;
    DXIL                            :: 10;
    DXIL_ASM                        :: 11;
    C_SOURCE                        :: 12;
    CPP_SOURCE                      :: 13;
    HOST_EXECUTABLE                 :: 14;
    SHADER_SHARED_LIBRARY           :: 15;

    SHADER_HOST_CALLABLE            :: 16;

    CUDA_SOURCE                     :: 17;
    PTX                             :: 18;
    CUDA_OBJECT_CODE                :: 19;
    OBJECT_CODE                     :: 20;
    HOST_CPP_SOURCE                 :: 21;
    HOST_HOST_CALLABLE              :: 22;
    CPP_PYTORCH_BINDING             :: 23;
    METAL                           :: 24;
    METAL_LIB                       :: 25;
    METAL_LIB_ASM                   :: 26;
    HOST_SHARED_LIBRARY             :: 27;
    WGSL                            :: 28;
    WGSL_SPIRV_ASM                  :: 29;
    WGSL_SPIRV                      :: 30;

    HOST_VM                         :: 31;
    TARGET_COUNT_OF                 :: 32;

    SLANG_TARGET_UNKNOWN                  :: TARGET_UNKNOWN;
    SLANG_TARGET_NONE                     :: TARGET_NONE;
    SLANG_GLSL                            :: GLSL;
    SLANG_GLSL_VULKAN_DEPRECATED          :: GLSL_VULKAN_DEPRECATED;
    SLANG_GLSL_VULKAN_ONE_DESC_DEPRECATED :: GLSL_VULKAN_ONE_DESC_DEPRECATED;
    SLANG_HLSL                            :: HLSL;
    SLANG_SPIRV                           :: SPIRV;
    SLANG_SPIRV_ASM                       :: SPIRV_ASM;
    SLANG_DXBC                            :: DXBC;
    SLANG_DXBC_ASM                        :: DXBC_ASM;
    SLANG_DXIL                            :: DXIL;
    SLANG_DXIL_ASM                        :: DXIL_ASM;
    SLANG_C_SOURCE                        :: C_SOURCE;
    SLANG_CPP_SOURCE                      :: CPP_SOURCE;
    SLANG_HOST_EXECUTABLE                 :: HOST_EXECUTABLE;
    SLANG_SHADER_SHARED_LIBRARY           :: SHADER_SHARED_LIBRARY;

    SLANG_SHADER_HOST_CALLABLE            :: SHADER_HOST_CALLABLE;

    SLANG_CUDA_SOURCE                     :: CUDA_SOURCE;
    SLANG_PTX                             :: PTX;
    SLANG_CUDA_OBJECT_CODE                :: CUDA_OBJECT_CODE;
    SLANG_OBJECT_CODE                     :: OBJECT_CODE;
    SLANG_HOST_CPP_SOURCE                 :: HOST_CPP_SOURCE;
    SLANG_HOST_HOST_CALLABLE              :: HOST_HOST_CALLABLE;
    SLANG_CPP_PYTORCH_BINDING             :: CPP_PYTORCH_BINDING;
    SLANG_METAL                           :: METAL;
    SLANG_METAL_LIB                       :: METAL_LIB;
    SLANG_METAL_LIB_ASM                   :: METAL_LIB_ASM;
    SLANG_HOST_SHARED_LIBRARY             :: HOST_SHARED_LIBRARY;
    SLANG_WGSL                            :: WGSL;
    SLANG_WGSL_SPIRV_ASM                  :: WGSL_SPIRV_ASM;
    SLANG_WGSL_SPIRV                      :: WGSL_SPIRV;

    SLANG_HOST_VM                         :: HOST_VM;
    SLANG_TARGET_COUNT_OF                 :: TARGET_COUNT_OF;
}

/* A "container format" describes the way that the outputs
for multiple files, entry points, targets, etc. should be
combined into a single artifact for output. */
SlangContainerFormatIntegral :: s32;
SlangContainerFormat :: enum SlangContainerFormatIntegral {
    NONE         :: 0;

    SLANG_MODULE :: 1;

    SLANG_CONTAINER_FORMAT_NONE         :: NONE;

    SLANG_CONTAINER_FORMAT_SLANG_MODULE :: SLANG_MODULE;
}

SlangPassThroughIntegral :: s32;
SlangPassThrough :: enum SlangPassThroughIntegral {
    NONE          :: 0;
    FXC           :: 1;
    DXC           :: 2;
    GLSLANG       :: 3;
    SPIRV_DIS     :: 4;
    CLANG         :: 5;
    VISUAL_STUDIO :: 6;
    GCC           :: 7;
    GENERIC_C_CPP :: 8;

    NVRTC         :: 9;
    LLVM          :: 10;
    SPIRV_OPT     :: 11;
    METAL         :: 12;
    TINT          :: 13;
    SPIRV_LINK    :: 14;
    COUNT_OF      :: 15;

    SLANG_PASS_THROUGH_NONE          :: NONE;
    SLANG_PASS_THROUGH_FXC           :: FXC;
    SLANG_PASS_THROUGH_DXC           :: DXC;
    SLANG_PASS_THROUGH_GLSLANG       :: GLSLANG;
    SLANG_PASS_THROUGH_SPIRV_DIS     :: SPIRV_DIS;
    SLANG_PASS_THROUGH_CLANG         :: CLANG;
    SLANG_PASS_THROUGH_VISUAL_STUDIO :: VISUAL_STUDIO;
    SLANG_PASS_THROUGH_GCC           :: GCC;
    SLANG_PASS_THROUGH_GENERIC_C_CPP :: GENERIC_C_CPP;

    SLANG_PASS_THROUGH_NVRTC         :: NVRTC;
    SLANG_PASS_THROUGH_LLVM          :: LLVM;
    SLANG_PASS_THROUGH_SPIRV_OPT     :: SPIRV_OPT;
    SLANG_PASS_THROUGH_METAL         :: METAL;
    SLANG_PASS_THROUGH_TINT          :: TINT;
    SLANG_PASS_THROUGH_SPIRV_LINK    :: SPIRV_LINK;
    SLANG_PASS_THROUGH_COUNT_OF      :: COUNT_OF;
}

/* Defines an archive type used to holds a 'file system' type structure. */
SlangArchiveTypeIntegral :: s32;
SlangArchiveType :: enum SlangArchiveTypeIntegral {
    UNDEFINED    :: 0;
    ZIP          :: 1;
    RIFF         :: 2;
    RIFF_DEFLATE :: 3;
    RIFF_LZ4     :: 4;
    COUNT_OF     :: 5;

    SLANG_ARCHIVE_TYPE_UNDEFINED    :: UNDEFINED;
    SLANG_ARCHIVE_TYPE_ZIP          :: ZIP;
    SLANG_ARCHIVE_TYPE_RIFF         :: RIFF;
    SLANG_ARCHIVE_TYPE_RIFF_DEFLATE :: RIFF_DEFLATE;
    SLANG_ARCHIVE_TYPE_RIFF_LZ4     :: RIFF_LZ4;
    SLANG_ARCHIVE_TYPE_COUNT_OF     :: COUNT_OF;
}

/*!
Flags to control compilation behavior.
*/
SlangCompileFlags :: u32;
SLANG_COMPILE_FLAG :: enum s32 {
    NO_MANGLING       :: 8;

    NO_CODEGEN        :: 16;

    OBFUSCATE         :: 32;

    NO_CHECKING       :: 0;
    SPLIT_MIXED_TYPES :: 0;

    SLANG_COMPILE_FLAG_NO_MANGLING       :: NO_MANGLING;

    SLANG_COMPILE_FLAG_NO_CODEGEN        :: NO_CODEGEN;

    SLANG_COMPILE_FLAG_OBFUSCATE         :: OBFUSCATE;

    SLANG_COMPILE_FLAG_NO_CHECKING       :: NO_CHECKING;
    SLANG_COMPILE_FLAG_SPLIT_MIXED_TYPES :: SPLIT_MIXED_TYPES;
}

/*!
@brief Flags to control code generation behavior of a compilation target */
SlangTargetFlags :: u32;
SLANG_TARGET_FLAG :: enum s32 {
    PARAMETER_BLOCKS_USE_REGISTER_SPACES :: 16;

    GENERATE_WHOLE_PROGRAM               :: 256;

    DUMP_IR                              :: 512;

    GENERATE_SPIRV_DIRECTLY              :: 1024;

    SLANG_TARGET_FLAG_PARAMETER_BLOCKS_USE_REGISTER_SPACES :: PARAMETER_BLOCKS_USE_REGISTER_SPACES;

    SLANG_TARGET_FLAG_GENERATE_WHOLE_PROGRAM               :: GENERATE_WHOLE_PROGRAM;

    SLANG_TARGET_FLAG_DUMP_IR                              :: DUMP_IR;

    SLANG_TARGET_FLAG_GENERATE_SPIRV_DIRECTLY              :: GENERATE_SPIRV_DIRECTLY;
}

kDefaultTargetFlags: SlangTargetFlags : xx SLANG_TARGET_FLAG.GENERATE_SPIRV_DIRECTLY;

/*!
@brief Options to control floating-point precision guarantees for a target.
*/
SlangFloatingPointModeIntegral :: u32;
SlangFloatingPointMode :: enum SlangFloatingPointModeIntegral {
    DEFAULT :: 0;
    FAST    :: 1;
    PRECISE :: 2;

    SLANG_FLOATING_POINT_MODE_DEFAULT :: DEFAULT;
    SLANG_FLOATING_POINT_MODE_FAST    :: FAST;
    SLANG_FLOATING_POINT_MODE_PRECISE :: PRECISE;
}

/*!
@brief Options to control floating-point denormal handling mode for a target.
*/
SlangFpDenormalModeIntegral :: u32;
SlangFpDenormalMode :: enum SlangFpDenormalModeIntegral {
    ANY      :: 0;
    PRESERVE :: 1;
    FTZ      :: 2;

    SLANG_FP_DENORM_MODE_ANY      :: ANY;
    SLANG_FP_DENORM_MODE_PRESERVE :: PRESERVE;
    SLANG_FP_DENORM_MODE_FTZ      :: FTZ;
}

/*!
@brief Options to control emission of `#line` directives
*/
SlangLineDirectiveModeIntegral :: u32;
SlangLineDirectiveMode :: enum SlangLineDirectiveModeIntegral {
    DEFAULT    :: 0;

    NONE       :: 1;
    STANDARD   :: 2;
    GLSL       :: 3;

    SOURCE_MAP :: 4;

    SLANG_LINE_DIRECTIVE_MODE_DEFAULT    :: DEFAULT;

    SLANG_LINE_DIRECTIVE_MODE_NONE       :: NONE;
    SLANG_LINE_DIRECTIVE_MODE_STANDARD   :: STANDARD;
    SLANG_LINE_DIRECTIVE_MODE_GLSL       :: GLSL;

    SLANG_LINE_DIRECTIVE_MODE_SOURCE_MAP :: SOURCE_MAP;
}

SlangSourceLanguageIntegral :: s32;
SlangSourceLanguage :: enum SlangSourceLanguageIntegral {
    UNKNOWN  :: 0;
    SLANG    :: 1;
    HLSL     :: 2;
    GLSL     :: 3;
    C        :: 4;
    CPP      :: 5;
    CUDA     :: 6;
    SPIRV    :: 7;
    METAL    :: 8;
    WGSL     :: 9;
    COUNT_OF :: 10;

    SLANG_SOURCE_LANGUAGE_UNKNOWN  :: UNKNOWN;
    SLANG_SOURCE_LANGUAGE_SLANG    :: SLANG;
    SLANG_SOURCE_LANGUAGE_HLSL     :: HLSL;
    SLANG_SOURCE_LANGUAGE_GLSL     :: GLSL;
    SLANG_SOURCE_LANGUAGE_C        :: C;
    SLANG_SOURCE_LANGUAGE_CPP      :: CPP;
    SLANG_SOURCE_LANGUAGE_CUDA     :: CUDA;
    SLANG_SOURCE_LANGUAGE_SPIRV    :: SPIRV;
    SLANG_SOURCE_LANGUAGE_METAL    :: METAL;
    SLANG_SOURCE_LANGUAGE_WGSL     :: WGSL;
    SLANG_SOURCE_LANGUAGE_COUNT_OF :: COUNT_OF;
}

SlangProfileIDIntegral :: u32;
SlangProfileID :: enum SlangProfileIDIntegral {
    SLANG_PROFILE_UNKNOWN :: 0;
}

SlangCapabilityIDIntegral :: SlangInt32;
SlangCapabilityID :: enum SlangCapabilityIDIntegral {
    SLANG_CAPABILITY_UNKNOWN :: 0;
}

SlangMatrixLayoutModeIntegral :: u32;
SlangMatrixLayoutMode :: enum SlangMatrixLayoutModeIntegral {
    MODE_UNKNOWN :: 0;
    ROW_MAJOR    :: 1;
    COLUMN_MAJOR :: 2;

    SLANG_MATRIX_LAYOUT_MODE_UNKNOWN :: MODE_UNKNOWN;
    SLANG_MATRIX_LAYOUT_ROW_MAJOR    :: ROW_MAJOR;
    SLANG_MATRIX_LAYOUT_COLUMN_MAJOR :: COLUMN_MAJOR;
}

SlangStageIntegral :: SlangUInt32;
SlangStage :: enum SlangStageIntegral {
    NONE           :: 0;
    VERTEX         :: 1;
    HULL           :: 2;
    DOMAIN         :: 3;
    GEOMETRY       :: 4;
    FRAGMENT       :: 5;
    COMPUTE        :: 6;
    RAY_GENERATION :: 7;
    INTERSECTION   :: 8;
    ANY_HIT        :: 9;
    CLOSEST_HIT    :: 10;
    MISS           :: 11;
    CALLABLE       :: 12;
    MESH           :: 13;
    AMPLIFICATION  :: 14;
    DISPATCH       :: 15;

    COUNT          :: 16;

    PIXEL          :: 5;

    SLANG_STAGE_NONE           :: NONE;
    SLANG_STAGE_VERTEX         :: VERTEX;
    SLANG_STAGE_HULL           :: HULL;
    SLANG_STAGE_DOMAIN         :: DOMAIN;
    SLANG_STAGE_GEOMETRY       :: GEOMETRY;
    SLANG_STAGE_FRAGMENT       :: FRAGMENT;
    SLANG_STAGE_COMPUTE        :: COMPUTE;
    SLANG_STAGE_RAY_GENERATION :: RAY_GENERATION;
    SLANG_STAGE_INTERSECTION   :: INTERSECTION;
    SLANG_STAGE_ANY_HIT        :: ANY_HIT;
    SLANG_STAGE_CLOSEST_HIT    :: CLOSEST_HIT;
    SLANG_STAGE_MISS           :: MISS;
    SLANG_STAGE_CALLABLE       :: CALLABLE;
    SLANG_STAGE_MESH           :: MESH;
    SLANG_STAGE_AMPLIFICATION  :: AMPLIFICATION;
    SLANG_STAGE_DISPATCH       :: DISPATCH;

    SLANG_STAGE_COUNT          :: COUNT;

    SLANG_STAGE_PIXEL          :: PIXEL;
}

SlangDebugInfoLevelIntegral :: SlangUInt32;
SlangDebugInfoLevel :: enum SlangDebugInfoLevelIntegral {
    NONE     :: 0;
    MINIMAL  :: 1;

    STANDARD :: 2;

    MAXIMAL  :: 3;

    SLANG_DEBUG_INFO_LEVEL_NONE     :: NONE;
    SLANG_DEBUG_INFO_LEVEL_MINIMAL  :: MINIMAL;

    SLANG_DEBUG_INFO_LEVEL_STANDARD :: STANDARD;

    SLANG_DEBUG_INFO_LEVEL_MAXIMAL  :: MAXIMAL;
}

/* Describes the debugging information format produced during a compilation. */
SlangDebugInfoFormatIntegral :: SlangUInt32;
SlangDebugInfoFormat :: enum SlangDebugInfoFormatIntegral {
    DEFAULT  :: 0;
    C7       :: 1;

    PDB      :: 2;

    STABS    :: 3;
    COFF     :: 4;
    DWARF    :: 5;

    COUNT_OF :: 6;

    SLANG_DEBUG_INFO_FORMAT_DEFAULT  :: DEFAULT;
    SLANG_DEBUG_INFO_FORMAT_C7       :: C7;

    SLANG_DEBUG_INFO_FORMAT_PDB      :: PDB;

    SLANG_DEBUG_INFO_FORMAT_STABS    :: STABS;
    SLANG_DEBUG_INFO_FORMAT_COFF     :: COFF;
    SLANG_DEBUG_INFO_FORMAT_DWARF    :: DWARF;

    SLANG_DEBUG_INFO_FORMAT_COUNT_OF :: COUNT_OF;
}

SlangOptimizationLevelIntegral :: SlangUInt32;
SlangOptimizationLevel :: enum SlangOptimizationLevelIntegral {
    NONE    :: 0;
    DEFAULT :: 1;

    HIGH    :: 2;
    MAXIMAL :: 3;

    SLANG_OPTIMIZATION_LEVEL_NONE    :: NONE;
    SLANG_OPTIMIZATION_LEVEL_DEFAULT :: DEFAULT;

    SLANG_OPTIMIZATION_LEVEL_HIGH    :: HIGH;
    SLANG_OPTIMIZATION_LEVEL_MAXIMAL :: MAXIMAL;
}

SlangEmitSpirvMethod :: enum s32 {
    DEFAULT  :: 0;
    VIA_GLSL :: 1;
    DIRECTLY :: 2;

    SLANG_EMIT_SPIRV_DEFAULT  :: DEFAULT;
    SLANG_EMIT_SPIRV_VIA_GLSL :: VIA_GLSL;
    SLANG_EMIT_SPIRV_DIRECTLY :: DIRECTLY;
}
// All compiler option names supported by Slang.

CompilerOptionName :: enum s32 {
    MacroDefine                       :: 0;
    DepFile                           :: 1;
    EntryPointName                    :: 2;
    Specialize                        :: 3;
    Help                              :: 4;
    HelpStyle                         :: 5;
    Include                           :: 6;
    Language                          :: 7;
    MatrixLayoutColumn                :: 8;
    MatrixLayoutRow                   :: 9;
    ZeroInitialize                    :: 10;
    IgnoreCapabilities                :: 11;
    RestrictiveCapabilityCheck        :: 12;
    ModuleName                        :: 13;
    Output                            :: 14;
    Profile                           :: 15;
    Stage                             :: 16;
    Target                            :: 17;
    Version                           :: 18;
    WarningsAsErrors                  :: 19;
    DisableWarnings                   :: 20;
    EnableWarning                     :: 21;
    DisableWarning                    :: 22;
    DumpWarningDiagnostics            :: 23;
    InputFilesRemain                  :: 24;
    EmitIr                            :: 25;
    ReportDownstreamTime              :: 26;
    ReportPerfBenchmark               :: 27;
    ReportCheckpointIntermediates     :: 28;
    SkipSPIRVValidation               :: 29;
    SourceEmbedStyle                  :: 30;
    SourceEmbedName                   :: 31;
    SourceEmbedLanguage               :: 32;
    DisableShortCircuit               :: 33;
    MinimumSlangOptimization          :: 34;
    DisableNonEssentialValidations    :: 35;
    DisableSourceMap                  :: 36;
    UnscopedEnum                      :: 37;
    PreserveParameters                :: 38;

    Capability                        :: 39;
    DefaultImageFormatUnknown         :: 40;
    DisableDynamicDispatch            :: 41;
    DisableSpecialization             :: 42;
    FloatingPointMode                 :: 43;
    DebugInformation                  :: 44;
    LineDirectiveMode                 :: 45;
    Optimization                      :: 46;
    Obfuscate                         :: 47;

    VulkanBindShift                   :: 48;

    VulkanBindGlobals                 :: 49;
    VulkanInvertY                     :: 50;
    VulkanUseDxPositionW              :: 51;
    VulkanUseEntryPointName           :: 52;
    VulkanUseGLLayout                 :: 53;
    VulkanEmitReflection              :: 54;

    GLSLForceScalarLayout             :: 55;
    EnableEffectAnnotations           :: 56;

    EmitSpirvViaGLSL                  :: 57;
    EmitSpirvDirectly                 :: 58;
    SPIRVCoreGrammarJSON              :: 59;
    IncompleteLibrary                 :: 60;

    CompilerPath                      :: 61;
    DefaultDownstreamCompiler         :: 62;
    DownstreamArgs                    :: 63;

    PassThrough                       :: 64;

    DumpRepro                         :: 65;
    DumpReproOnError                  :: 66;
    ExtractRepro                      :: 67;
    LoadRepro                         :: 68;
    LoadReproDirectory                :: 69;
    ReproFallbackDirectory            :: 70;

    DumpAst                           :: 71;
    DumpIntermediatePrefix            :: 72;
    DumpIntermediates                 :: 73;
    DumpIr                            :: 74;
    DumpIrIds                         :: 75;
    PreprocessorOutput                :: 76;
    OutputIncludes                    :: 77;
    ReproFileSystem                   :: 78;
    REMOVED_SerialIR                  :: 79;
    SkipCodeGen                       :: 80;
    ValidateIr                        :: 81;
    VerbosePaths                      :: 82;
    VerifyDebugSerialIr               :: 83;
    NoCodeGen                         :: 84;

    FileSystem                        :: 85;
    Heterogeneous                     :: 86;
    NoMangle                          :: 87;
    NoHLSLBinding                     :: 88;
    NoHLSLPackConstantBufferElements  :: 89;
    ValidateUniformity                :: 90;
    AllowGLSL                         :: 91;
    EnableExperimentalPasses          :: 92;
    BindlessSpaceIndex                :: 93;

    ArchiveType                       :: 94;
    CompileCoreModule                 :: 95;
    Doc                               :: 96;

    IrCompression                     :: 97;

    LoadCoreModule                    :: 98;
    ReferenceModule                   :: 99;
    SaveCoreModule                    :: 100;
    SaveCoreModuleBinSource           :: 101;
    TrackLiveness                     :: 102;
    LoopInversion                     :: 103;

    ParameterBlocksUseRegisterSpaces  :: 104;
    LanguageVersion                   :: 105;
    TypeConformance                   :: 106;

    EnableExperimentalDynamicDispatch :: 107;
    EmitReflectionJSON                :: 108;

    CountOfParsableOptions            :: 109;

    DebugInformationFormat            :: 110;
    VulkanBindShiftAll                :: 111;
    GenerateWholeProgram              :: 112;
    UseUpToDateBinaryModule           :: 113;

    EmbedDownstreamIR                 :: 114;
    ForceDXLayout                     :: 115;

    EmitSpirvMethod                   :: 116;

    SaveGLSLModuleBinSource           :: 117;

    SkipDownstreamLinking             :: 118;
    DumpModule                        :: 119;

    GetModuleInfo                     :: 120;
    GetSupportedModuleVersions        :: 121;

    EmitSeparateDebug                 :: 122;

    DenormalModeFp16                  :: 123;
    DenormalModeFp32                  :: 124;
    DenormalModeFp64                  :: 125;

    CountOf                           :: 126;
}

CompilerOptionValueKind :: enum s32 {
    Int    :: 0;
    String :: 1;
}

CompilerOptionValue :: struct {
    kind:         CompilerOptionValueKind = .Int;
    intValue0:    s32 = 0;
    intValue1:    s32 = 0;
    stringValue0: *u8 = null;
    stringValue1: *u8 = null;
}

CompilerOptionEntry :: struct {
    name:  CompilerOptionName;
    value: CompilerOptionValue;
}

/*!
@brief A request for one or more compilation actions to be performed.
*/
ICompileRequest :: struct {
    vtable: *ICompileRequest_VTable;
    #place vtable; #as islangunknown: ISlangUnknown; // Support cast to ISlangUnknown
}
ICompileRequest_VTable :: struct #type_info_none {
    using vtable:                                 ISlangUnknown_VTable;
    setFileSystem:                                #type (this: *ICompileRequest, fileSystem: *ISlangFileSystem) -> void #cpp_method;
    setCompileFlags:                              #type (this: *ICompileRequest, flags: SlangCompileFlags) -> void #cpp_method;
    getCompileFlags:                              #type (this: *ICompileRequest) -> SlangCompileFlags #cpp_method;
    setDumpIntermediates:                         #type (this: *ICompileRequest, enable: s32) -> void #cpp_method;
    setDumpIntermediatePrefix:                    #type (this: *ICompileRequest, prefix: *u8) -> void #cpp_method;
    setLineDirectiveMode:                         #type (this: *ICompileRequest, mode: SlangLineDirectiveMode) -> void #cpp_method;
    setCodeGenTarget:                             #type (this: *ICompileRequest, target: SlangCompileTarget) -> void #cpp_method;
    addCodeGenTarget:                             #type (this: *ICompileRequest, target: SlangCompileTarget) -> s32 #cpp_method;
    setTargetProfile:                             #type (this: *ICompileRequest, targetIndex: s32, profile: SlangProfileID) -> void #cpp_method;
    setTargetFlags:                               #type (this: *ICompileRequest, targetIndex: s32, flags: SlangTargetFlags) -> void #cpp_method;
    setTargetFloatingPointMode:                   #type (this: *ICompileRequest, targetIndex: s32, mode: SlangFloatingPointMode) -> void #cpp_method;
    setTargetMatrixLayoutMode:                    #type (this: *ICompileRequest, targetIndex: s32, mode: SlangMatrixLayoutMode) -> void #cpp_method;
    setMatrixLayoutMode:                          #type (this: *ICompileRequest, mode: SlangMatrixLayoutMode) -> void #cpp_method;
    setDebugInfoLevel:                            #type (this: *ICompileRequest, level: SlangDebugInfoLevel) -> void #cpp_method;
    setOptimizationLevel:                         #type (this: *ICompileRequest, level: SlangOptimizationLevel) -> void #cpp_method;
    setOutputContainerFormat:                     #type (this: *ICompileRequest, format: SlangContainerFormat) -> void #cpp_method;
    setPassThrough:                               #type (this: *ICompileRequest, passThrough: SlangPassThrough) -> void #cpp_method;
    setDiagnosticCallback:                        #type (this: *ICompileRequest, callback: SlangDiagnosticCallback, userData: *void) -> void #cpp_method;
    setWriter:                                    #type (this: *ICompileRequest, channel: SlangWriterChannel, writer: *ISlangWriter) -> void #cpp_method;
    getWriter:                                    #type (this: *ICompileRequest, channel: SlangWriterChannel) -> *ISlangWriter #cpp_method;
    addSearchPath:                                #type (this: *ICompileRequest, searchDir: *u8) -> void #cpp_method;
    addPreprocessorDefine:                        #type (this: *ICompileRequest, key: *u8, value: *u8) -> void #cpp_method;
    processCommandLineArguments:                  #type (this: *ICompileRequest, args: **u8, argCount: s32) -> SlangResult #cpp_method;
    addTranslationUnit:                           #type (this: *ICompileRequest, language: SlangSourceLanguage, name: *u8) -> s32 #cpp_method;
    setDefaultModuleName:                         #type (this: *ICompileRequest, defaultModuleName: *u8) -> void #cpp_method;
    addTranslationUnitPreprocessorDefine:         #type (this: *ICompileRequest, translationUnitIndex: s32, key: *u8, value: *u8) -> void #cpp_method;
    addTranslationUnitSourceFile:                 #type (this: *ICompileRequest, translationUnitIndex: s32, path: *u8) -> void #cpp_method;
    addTranslationUnitSourceString:               #type (this: *ICompileRequest, translationUnitIndex: s32, path: *u8, source: *u8) -> void #cpp_method;
    addLibraryReference:                          #type (this: *ICompileRequest, basePath: *u8, libData: *void, libDataSize: u64) -> SlangResult #cpp_method;
    addTranslationUnitSourceStringSpan:           #type (this: *ICompileRequest, translationUnitIndex: s32, path: *u8, sourceBegin: *u8, sourceEnd: *u8) -> void #cpp_method;
    addTranslationUnitSourceBlob:                 #type (this: *ICompileRequest, translationUnitIndex: s32, path: *u8, sourceBlob: *ISlangBlob) -> void #cpp_method;
    addEntryPoint:                                #type (this: *ICompileRequest, translationUnitIndex: s32, name: *u8, stage: SlangStage) -> s32 #cpp_method;
    addEntryPointEx:                              #type (this: *ICompileRequest, translationUnitIndex: s32, name: *u8, stage: SlangStage, genericArgCount: s32, genericArgs: **u8) -> s32 #cpp_method;
    setGlobalGenericArgs:                         #type (this: *ICompileRequest, genericArgCount: s32, genericArgs: **u8) -> SlangResult #cpp_method;
    setTypeNameForGlobalExistentialTypeParam:     #type (this: *ICompileRequest, slotIndex: s32, typeName: *u8) -> SlangResult #cpp_method;
    setTypeNameForEntryPointExistentialTypeParam: #type (this: *ICompileRequest, entryPointIndex: s32, slotIndex: s32, typeName: *u8) -> SlangResult #cpp_method;
    setAllowGLSLInput:                            #type (this: *ICompileRequest, value: bool) -> void #cpp_method;
    compile:                                      #type (this: *ICompileRequest) -> SlangResult #cpp_method;
    getDiagnosticOutput:                          #type (this: *ICompileRequest) -> *u8 #cpp_method;
    getDiagnosticOutputBlob:                      #type (this: *ICompileRequest, outBlob: **ISlangBlob) -> SlangResult #cpp_method;
    getDependencyFileCount:                       #type (this: *ICompileRequest) -> s32 #cpp_method;
    getDependencyFilePath:                        #type (this: *ICompileRequest, index: s32) -> *u8 #cpp_method;
    getTranslationUnitCount:                      #type (this: *ICompileRequest) -> s32 #cpp_method;
    getEntryPointSource:                          #type (this: *ICompileRequest, entryPointIndex: s32) -> *u8 #cpp_method;
    getEntryPointCode:                            #type (this: *ICompileRequest, entryPointIndex: s32, outSize: *u64) -> *void #cpp_method;
    getEntryPointCodeBlob:                        #type (this: *ICompileRequest, entryPointIndex: s32, targetIndex: s32, outBlob: **ISlangBlob) -> SlangResult #cpp_method;
    getEntryPointHostCallable:                    #type (this: *ICompileRequest, entryPointIndex: s32, targetIndex: s32, outSharedLibrary: **ISlangSharedLibrary) -> SlangResult #cpp_method;
    getTargetCodeBlob:                            #type (this: *ICompileRequest, targetIndex: s32, outBlob: **ISlangBlob) -> SlangResult #cpp_method;
    getTargetHostCallable:                        #type (this: *ICompileRequest, targetIndex: s32, outSharedLibrary: **ISlangSharedLibrary) -> SlangResult #cpp_method;
    getCompileRequestCode:                        #type (this: *ICompileRequest, outSize: *u64) -> *void #cpp_method;
    getCompileRequestResultAsFileSystem:          #type (this: *ICompileRequest) -> *ISlangMutableFileSystem #cpp_method;
    getContainerCode:                             #type (this: *ICompileRequest, outBlob: **ISlangBlob) -> SlangResult #cpp_method;
    loadRepro:                                    #type (this: *ICompileRequest, fileSystem: *ISlangFileSystem, data: *void, size: u64) -> SlangResult #cpp_method;
    saveRepro:                                    #type (this: *ICompileRequest, outBlob: **ISlangBlob) -> SlangResult #cpp_method;
    enableReproCapture:                           #type (this: *ICompileRequest) -> SlangResult #cpp_method;
    getProgram:                                   #type (this: *ICompileRequest, outProgram: **IComponentType) -> SlangResult #cpp_method;
    getEntryPoint:                                #type (this: *ICompileRequest, entryPointIndex: SlangInt, outEntryPoint: **IComponentType) -> SlangResult #cpp_method;
    getModule:                                    #type (this: *ICompileRequest, translationUnitIndex: SlangInt, outModule: **IModule) -> SlangResult #cpp_method;
    getSession:                                   #type (this: *ICompileRequest, outSession: **ISession) -> SlangResult #cpp_method;
    getReflection:                                #type (this: *ICompileRequest) -> *SlangReflection #cpp_method;
    setCommandLineCompilerMode:                   #type (this: *ICompileRequest) -> void #cpp_method;
    addTargetCapability:                          #type (this: *ICompileRequest, targetIndex: SlangInt, capability: SlangCapabilityID) -> SlangResult #cpp_method;
    getProgramWithEntryPoints:                    #type (this: *ICompileRequest, outProgram: **IComponentType) -> SlangResult #cpp_method;
    isParameterLocationUsed:                      #type (this: *ICompileRequest, entryPointIndex: SlangInt, targetIndex: SlangInt, category: SlangParameterCategory, spaceIndex: SlangUInt, registerIndex: SlangUInt, outUsed: *bool) -> SlangResult #cpp_method;
    setTargetLineDirectiveMode:                   #type (this: *ICompileRequest, targetIndex: SlangInt, mode: SlangLineDirectiveMode) -> void #cpp_method;
    setTargetForceGLSLScalarBufferLayout:         #type (this: *ICompileRequest, targetIndex: s32, forceScalarLayout: bool) -> void #cpp_method;
    overrideDiagnosticSeverity:                   #type (this: *ICompileRequest, messageID: SlangInt, overrideSeverity: SlangSeverity) -> void #cpp_method;
    getDiagnosticFlags:                           #type (this: *ICompileRequest) -> SlangDiagnosticFlags #cpp_method;
    setDiagnosticFlags:                           #type (this: *ICompileRequest, flags: SlangDiagnosticFlags) -> void #cpp_method;
    setDebugInfoFormat:                           #type (this: *ICompileRequest, debugFormat: SlangDebugInfoFormat) -> void #cpp_method;
    setEnableEffectAnnotations:                   #type (this: *ICompileRequest, value: bool) -> void #cpp_method;
    setReportDownstreamTime:                      #type (this: *ICompileRequest, value: bool) -> void #cpp_method;
    setReportPerfBenchmark:                       #type (this: *ICompileRequest, value: bool) -> void #cpp_method;
    setSkipSPIRVValidation:                       #type (this: *ICompileRequest, value: bool) -> void #cpp_method;
    setTargetUseMinimumSlangOptimization:         #type (this: *ICompileRequest, targetIndex: s32, value: bool) -> void #cpp_method;
    setIgnoreCapabilityCheck:                     #type (this: *ICompileRequest, value: bool) -> void #cpp_method;
    getCompileTimeProfile:                        #type (this: *ICompileRequest, compileTimeProfile: **ISlangProfiler, shouldClear: bool) -> SlangResult #cpp_method;
    setTargetGenerateWholeProgram:                #type (this: *ICompileRequest, targetIndex: s32, value: bool) -> void #cpp_method;
    setTargetForceDXLayout:                       #type (this: *ICompileRequest, targetIndex: s32, value: bool) -> void #cpp_method;
    setTargetEmbedDownstreamIR:                   #type (this: *ICompileRequest, targetIndex: s32, value: bool) -> void #cpp_method;
}
ICompileRequest_setFileSystem :: inline (this: *ICompileRequest, fileSystem: *ISlangFileSystem) { this.vtable.setFileSystem(this, fileSystem); }

ICompileRequest_setCompileFlags :: inline (this: *ICompileRequest, flags: SlangCompileFlags) { this.vtable.setCompileFlags(this, flags); }

ICompileRequest_getCompileFlags :: inline (this: *ICompileRequest) -> SlangCompileFlags { return this.vtable.getCompileFlags(this); }

ICompileRequest_setDumpIntermediates :: inline (this: *ICompileRequest, enable: s32) { this.vtable.setDumpIntermediates(this, enable); }

ICompileRequest_setDumpIntermediatePrefix :: inline (this: *ICompileRequest, prefix: *u8) { this.vtable.setDumpIntermediatePrefix(this, prefix); }

ICompileRequest_setLineDirectiveMode :: inline (this: *ICompileRequest, mode: SlangLineDirectiveMode) { this.vtable.setLineDirectiveMode(this, mode); }

ICompileRequest_setCodeGenTarget :: inline (this: *ICompileRequest, target: SlangCompileTarget) { this.vtable.setCodeGenTarget(this, target); }

ICompileRequest_addCodeGenTarget :: inline (this: *ICompileRequest, target: SlangCompileTarget) -> s32 { return this.vtable.addCodeGenTarget(this, target); }

ICompileRequest_setTargetProfile :: inline (this: *ICompileRequest, targetIndex: s32, profile: SlangProfileID) { this.vtable.setTargetProfile(this, targetIndex, profile); }

ICompileRequest_setTargetFlags :: inline (this: *ICompileRequest, targetIndex: s32, flags: SlangTargetFlags) { this.vtable.setTargetFlags(this, targetIndex, flags); }

ICompileRequest_setTargetFloatingPointMode :: inline (this: *ICompileRequest, targetIndex: s32, mode: SlangFloatingPointMode) { this.vtable.setTargetFloatingPointMode(this, targetIndex, mode); }

ICompileRequest_setTargetMatrixLayoutMode :: inline (this: *ICompileRequest, targetIndex: s32, mode: SlangMatrixLayoutMode) { this.vtable.setTargetMatrixLayoutMode(this, targetIndex, mode); }

ICompileRequest_setMatrixLayoutMode :: inline (this: *ICompileRequest, mode: SlangMatrixLayoutMode) { this.vtable.setMatrixLayoutMode(this, mode); }

ICompileRequest_setDebugInfoLevel :: inline (this: *ICompileRequest, level: SlangDebugInfoLevel) { this.vtable.setDebugInfoLevel(this, level); }

ICompileRequest_setOptimizationLevel :: inline (this: *ICompileRequest, level: SlangOptimizationLevel) { this.vtable.setOptimizationLevel(this, level); }

ICompileRequest_setOutputContainerFormat :: inline (this: *ICompileRequest, format: SlangContainerFormat) { this.vtable.setOutputContainerFormat(this, format); }

ICompileRequest_setPassThrough :: inline (this: *ICompileRequest, passThrough: SlangPassThrough) { this.vtable.setPassThrough(this, passThrough); }

ICompileRequest_setDiagnosticCallback :: inline (this: *ICompileRequest, callback: SlangDiagnosticCallback, userData: *void) { this.vtable.setDiagnosticCallback(this, callback, userData); }

ICompileRequest_setWriter :: inline (this: *ICompileRequest, channel: SlangWriterChannel, writer: *ISlangWriter) { this.vtable.setWriter(this, channel, writer); }

ICompileRequest_getWriter :: inline (this: *ICompileRequest, channel: SlangWriterChannel) -> *ISlangWriter { return this.vtable.getWriter(this, channel); }

ICompileRequest_addSearchPath :: inline (this: *ICompileRequest, searchDir: *u8) { this.vtable.addSearchPath(this, searchDir); }

ICompileRequest_addPreprocessorDefine :: inline (this: *ICompileRequest, key: *u8, value: *u8) { this.vtable.addPreprocessorDefine(this, key, value); }

ICompileRequest_processCommandLineArguments :: inline (this: *ICompileRequest, args: **u8, argCount: s32) -> SlangResult { return this.vtable.processCommandLineArguments(this, args, argCount); }

ICompileRequest_addTranslationUnit :: inline (this: *ICompileRequest, language: SlangSourceLanguage, name: *u8) -> s32 { return this.vtable.addTranslationUnit(this, language, name); }

ICompileRequest_setDefaultModuleName :: inline (this: *ICompileRequest, defaultModuleName: *u8) { this.vtable.setDefaultModuleName(this, defaultModuleName); }

ICompileRequest_addTranslationUnitPreprocessorDefine :: inline (this: *ICompileRequest, translationUnitIndex: s32, key: *u8, value: *u8) { this.vtable.addTranslationUnitPreprocessorDefine(this, translationUnitIndex, key, value); }

ICompileRequest_addTranslationUnitSourceFile :: inline (this: *ICompileRequest, translationUnitIndex: s32, path: *u8) { this.vtable.addTranslationUnitSourceFile(this, translationUnitIndex, path); }

ICompileRequest_addTranslationUnitSourceString :: inline (this: *ICompileRequest, translationUnitIndex: s32, path: *u8, source: *u8) { this.vtable.addTranslationUnitSourceString(this, translationUnitIndex, path, source); }

ICompileRequest_addLibraryReference :: inline (this: *ICompileRequest, basePath: *u8, libData: *void, libDataSize: u64) -> SlangResult { return this.vtable.addLibraryReference(this, basePath, libData, libDataSize); }

ICompileRequest_addTranslationUnitSourceStringSpan :: inline (this: *ICompileRequest, translationUnitIndex: s32, path: *u8, sourceBegin: *u8, sourceEnd: *u8) { this.vtable.addTranslationUnitSourceStringSpan(this, translationUnitIndex, path, sourceBegin, sourceEnd); }

ICompileRequest_addTranslationUnitSourceBlob :: inline (this: *ICompileRequest, translationUnitIndex: s32, path: *u8, sourceBlob: *ISlangBlob) { this.vtable.addTranslationUnitSourceBlob(this, translationUnitIndex, path, sourceBlob); }

ICompileRequest_addEntryPoint :: inline (this: *ICompileRequest, translationUnitIndex: s32, name: *u8, stage: SlangStage) -> s32 { return this.vtable.addEntryPoint(this, translationUnitIndex, name, stage); }

ICompileRequest_addEntryPointEx :: inline (this: *ICompileRequest, translationUnitIndex: s32, name: *u8, stage: SlangStage, genericArgCount: s32, genericArgs: **u8) -> s32 { return this.vtable.addEntryPointEx(this, translationUnitIndex, name, stage, genericArgCount, genericArgs); }

ICompileRequest_setGlobalGenericArgs :: inline (this: *ICompileRequest, genericArgCount: s32, genericArgs: **u8) -> SlangResult { return this.vtable.setGlobalGenericArgs(this, genericArgCount, genericArgs); }

ICompileRequest_setTypeNameForGlobalExistentialTypeParam :: inline (this: *ICompileRequest, slotIndex: s32, typeName: *u8) -> SlangResult { return this.vtable.setTypeNameForGlobalExistentialTypeParam(this, slotIndex, typeName); }

ICompileRequest_setTypeNameForEntryPointExistentialTypeParam :: inline (this: *ICompileRequest, entryPointIndex: s32, slotIndex: s32, typeName: *u8) -> SlangResult { return this.vtable.setTypeNameForEntryPointExistentialTypeParam(this, entryPointIndex, slotIndex, typeName); }

ICompileRequest_setAllowGLSLInput :: inline (this: *ICompileRequest, value: bool) { this.vtable.setAllowGLSLInput(this, value); }

ICompileRequest_compile :: inline (this: *ICompileRequest) -> SlangResult { return this.vtable.compile(this); }

ICompileRequest_getDiagnosticOutput :: inline (this: *ICompileRequest) -> *u8 { return this.vtable.getDiagnosticOutput(this); }

ICompileRequest_getDiagnosticOutputBlob :: inline (this: *ICompileRequest, outBlob: **ISlangBlob) -> SlangResult { return this.vtable.getDiagnosticOutputBlob(this, outBlob); }

ICompileRequest_getDependencyFileCount :: inline (this: *ICompileRequest) -> s32 { return this.vtable.getDependencyFileCount(this); }

ICompileRequest_getDependencyFilePath :: inline (this: *ICompileRequest, index: s32) -> *u8 { return this.vtable.getDependencyFilePath(this, index); }

ICompileRequest_getTranslationUnitCount :: inline (this: *ICompileRequest) -> s32 { return this.vtable.getTranslationUnitCount(this); }

ICompileRequest_getEntryPointSource :: inline (this: *ICompileRequest, entryPointIndex: s32) -> *u8 { return this.vtable.getEntryPointSource(this, entryPointIndex); }

ICompileRequest_getEntryPointCode :: inline (this: *ICompileRequest, entryPointIndex: s32, outSize: *u64) -> *void { return this.vtable.getEntryPointCode(this, entryPointIndex, outSize); }

ICompileRequest_getEntryPointCodeBlob :: inline (this: *ICompileRequest, entryPointIndex: s32, targetIndex: s32, outBlob: **ISlangBlob) -> SlangResult { return this.vtable.getEntryPointCodeBlob(this, entryPointIndex, targetIndex, outBlob); }

ICompileRequest_getEntryPointHostCallable :: inline (this: *ICompileRequest, entryPointIndex: s32, targetIndex: s32, outSharedLibrary: **ISlangSharedLibrary) -> SlangResult { return this.vtable.getEntryPointHostCallable(this, entryPointIndex, targetIndex, outSharedLibrary); }

ICompileRequest_getTargetCodeBlob :: inline (this: *ICompileRequest, targetIndex: s32, outBlob: **ISlangBlob) -> SlangResult { return this.vtable.getTargetCodeBlob(this, targetIndex, outBlob); }

ICompileRequest_getTargetHostCallable :: inline (this: *ICompileRequest, targetIndex: s32, outSharedLibrary: **ISlangSharedLibrary) -> SlangResult { return this.vtable.getTargetHostCallable(this, targetIndex, outSharedLibrary); }

ICompileRequest_getCompileRequestCode :: inline (this: *ICompileRequest, outSize: *u64) -> *void { return this.vtable.getCompileRequestCode(this, outSize); }

ICompileRequest_getCompileRequestResultAsFileSystem :: inline (this: *ICompileRequest) -> *ISlangMutableFileSystem { return this.vtable.getCompileRequestResultAsFileSystem(this); }

ICompileRequest_getContainerCode :: inline (this: *ICompileRequest, outBlob: **ISlangBlob) -> SlangResult { return this.vtable.getContainerCode(this, outBlob); }

ICompileRequest_loadRepro :: inline (this: *ICompileRequest, fileSystem: *ISlangFileSystem, data: *void, size: u64) -> SlangResult { return this.vtable.loadRepro(this, fileSystem, data, size); }

ICompileRequest_saveRepro :: inline (this: *ICompileRequest, outBlob: **ISlangBlob) -> SlangResult { return this.vtable.saveRepro(this, outBlob); }

ICompileRequest_enableReproCapture :: inline (this: *ICompileRequest) -> SlangResult { return this.vtable.enableReproCapture(this); }

ICompileRequest_getProgram :: inline (this: *ICompileRequest, outProgram: **IComponentType) -> SlangResult { return this.vtable.getProgram(this, outProgram); }

ICompileRequest_getEntryPoint :: inline (this: *ICompileRequest, entryPointIndex: SlangInt, outEntryPoint: **IComponentType) -> SlangResult { return this.vtable.getEntryPoint(this, entryPointIndex, outEntryPoint); }

ICompileRequest_getModule :: inline (this: *ICompileRequest, translationUnitIndex: SlangInt, outModule: **IModule) -> SlangResult { return this.vtable.getModule(this, translationUnitIndex, outModule); }

ICompileRequest_getSession :: inline (this: *ICompileRequest, outSession: **ISession) -> SlangResult { return this.vtable.getSession(this, outSession); }

ICompileRequest_getReflection :: inline (this: *ICompileRequest) -> *SlangReflection { return this.vtable.getReflection(this); }

ICompileRequest_setCommandLineCompilerMode :: inline (this: *ICompileRequest) { this.vtable.setCommandLineCompilerMode(this); }

ICompileRequest_addTargetCapability :: inline (this: *ICompileRequest, targetIndex: SlangInt, capability: SlangCapabilityID) -> SlangResult { return this.vtable.addTargetCapability(this, targetIndex, capability); }

ICompileRequest_getProgramWithEntryPoints :: inline (this: *ICompileRequest, outProgram: **IComponentType) -> SlangResult { return this.vtable.getProgramWithEntryPoints(this, outProgram); }

ICompileRequest_isParameterLocationUsed :: inline (this: *ICompileRequest, entryPointIndex: SlangInt, targetIndex: SlangInt, category: SlangParameterCategory, spaceIndex: SlangUInt, registerIndex: SlangUInt, outUsed: *bool) -> SlangResult { return this.vtable.isParameterLocationUsed(this, entryPointIndex, targetIndex, category, spaceIndex, registerIndex, outUsed); }

ICompileRequest_setTargetLineDirectiveMode :: inline (this: *ICompileRequest, targetIndex: SlangInt, mode: SlangLineDirectiveMode) { this.vtable.setTargetLineDirectiveMode(this, targetIndex, mode); }

ICompileRequest_setTargetForceGLSLScalarBufferLayout :: inline (this: *ICompileRequest, targetIndex: s32, forceScalarLayout: bool) { this.vtable.setTargetForceGLSLScalarBufferLayout(this, targetIndex, forceScalarLayout); }

ICompileRequest_overrideDiagnosticSeverity :: inline (this: *ICompileRequest, messageID: SlangInt, overrideSeverity: SlangSeverity) { this.vtable.overrideDiagnosticSeverity(this, messageID, overrideSeverity); }

ICompileRequest_getDiagnosticFlags :: inline (this: *ICompileRequest) -> SlangDiagnosticFlags { return this.vtable.getDiagnosticFlags(this); }

ICompileRequest_setDiagnosticFlags :: inline (this: *ICompileRequest, flags: SlangDiagnosticFlags) { this.vtable.setDiagnosticFlags(this, flags); }

ICompileRequest_setDebugInfoFormat :: inline (this: *ICompileRequest, debugFormat: SlangDebugInfoFormat) { this.vtable.setDebugInfoFormat(this, debugFormat); }

ICompileRequest_setEnableEffectAnnotations :: inline (this: *ICompileRequest, value: bool) { this.vtable.setEnableEffectAnnotations(this, value); }

ICompileRequest_setReportDownstreamTime :: inline (this: *ICompileRequest, value: bool) { this.vtable.setReportDownstreamTime(this, value); }

ICompileRequest_setReportPerfBenchmark :: inline (this: *ICompileRequest, value: bool) { this.vtable.setReportPerfBenchmark(this, value); }

ICompileRequest_setSkipSPIRVValidation :: inline (this: *ICompileRequest, value: bool) { this.vtable.setSkipSPIRVValidation(this, value); }

ICompileRequest_setTargetUseMinimumSlangOptimization :: inline (this: *ICompileRequest, targetIndex: s32, value: bool) { this.vtable.setTargetUseMinimumSlangOptimization(this, targetIndex, value); }

ICompileRequest_setIgnoreCapabilityCheck :: inline (this: *ICompileRequest, value: bool) { this.vtable.setIgnoreCapabilityCheck(this, value); }

ICompileRequest_getCompileTimeProfile :: inline (this: *ICompileRequest, compileTimeProfile: **ISlangProfiler, shouldClear: bool) -> SlangResult { return this.vtable.getCompileTimeProfile(this, compileTimeProfile, shouldClear); }

ICompileRequest_setTargetGenerateWholeProgram :: inline (this: *ICompileRequest, targetIndex: s32, value: bool) { this.vtable.setTargetGenerateWholeProgram(this, targetIndex, value); }

ICompileRequest_setTargetForceDXLayout :: inline (this: *ICompileRequest, targetIndex: s32, value: bool) { this.vtable.setTargetForceDXLayout(this, targetIndex, value); }

ICompileRequest_setTargetEmbedDownstreamIR :: inline (this: *ICompileRequest, targetIndex: s32, value: bool) { this.vtable.setTargetEmbedDownstreamIR(this, targetIndex, value); }

vtable :: (obj: *ICompileRequest) -> *ICompileRequest_VTable { return obj.vtable; }


BufferReflection :: struct {}

GenericArgReflection :: union {
    typeVal: *TypeReflection;
    intVal:  s64;
    boolVal: bool;
}

Attribute :: struct {
    using attribute__raw:   Attribute__RAW;
    __empty_struct_padding: u8; // C++ makes empty structs have length 1
}
// Attribute without empty struct padding. Needed to generate a C++-equivalent struct layout when "inheriting" from Attribute
Attribute__RAW :: struct {}

UserAttribute :: Attribute;

TypeReflection :: struct {
    using typereflection__raw: TypeReflection__RAW;
    __empty_struct_padding:    u8; // C++ makes empty structs have length 1
}
// TypeReflection without empty struct padding. Needed to generate a C++-equivalent struct layout when "inheriting" from TypeReflection
TypeReflection__RAW :: struct {
    Kind :: enum s32 {
        None                 :: 0;
        Struct               :: 1;
        Array                :: 2;
        Matrix               :: 3;
        Vector               :: 4;
        Scalar               :: 5;
        ConstantBuffer       :: 6;
        Resource             :: 7;
        SamplerState         :: 8;
        TextureBuffer        :: 9;
        ShaderStorageBuffer  :: 10;
        ParameterBlock       :: 11;
        GenericTypeParameter :: 12;
        Interface            :: 13;
        OutputStream         :: 14;
        Specialized          :: 16;
        Feedback             :: 17;
        Pointer              :: 18;
        DynamicResource      :: 19;
        MeshOutput           :: 15;
    }

    ScalarType :: enum SlangScalarTypeIntegral {
        None    :: 0;
        Void    :: 1;
        Bool    :: 2;
        Int32   :: 3;
        UInt32  :: 4;
        Int64   :: 5;
        UInt64  :: 6;
        Float16 :: 7;
        Float32 :: 8;
        Float64 :: 9;
        Int8    :: 10;
        UInt8   :: 11;
        Int16   :: 12;
        UInt16  :: 13;
    }
}

ParameterCategory :: enum SlangParameterCategoryIntegral {
    None                       :: 0;
    Mixed                      :: 1;
    ConstantBuffer             :: 2;
    ShaderResource             :: 3;
    UnorderedAccess            :: 4;
    VaryingInput               :: 5;
    VaryingOutput              :: 6;
    SamplerState               :: 7;
    Uniform                    :: 8;
    DescriptorTableSlot        :: 9;
    SpecializationConstant     :: 10;
    PushConstantBuffer         :: 11;
    RegisterSpace              :: 12;
    GenericResource            :: 13;

    RayPayload                 :: 14;
    HitAttributes              :: 15;
    CallablePayload            :: 16;

    ShaderRecord               :: 17;

    ExistentialTypeParam       :: 18;
    ExistentialObjectParam     :: 19;

    SubElementRegisterSpace    :: 20;

    InputAttachmentIndex       :: 21;

    MetalBuffer                :: 2;
    MetalTexture               :: 3;
    MetalArgumentBufferElement :: 22;
    MetalAttribute             :: 23;
    MetalPayload               :: 24;

    VertexInput                :: 5;
    FragmentOutput             :: 6;
}

BindingType :: enum SlangBindingTypeIntegral {
    Unknown                         :: 0;

    Sampler                         :: 1;
    Texture                         :: 2;
    ConstantBuffer                  :: 3;
    ParameterBlock                  :: 4;
    TypedBuffer                     :: 5;
    RawBuffer                       :: 6;
    CombinedTextureSampler          :: 7;
    InputRenderTarget               :: 8;
    InlineUniformData               :: 9;
    RayTracingAccelerationStructure :: 10;
    VaryingInput                    :: 11;
    VaryingOutput                   :: 12;
    ExistentialValue                :: 13;
    PushConstant                    :: 14;

    MutableFlag                     :: 256;

    MutableTexture                  :: 258;
    MutableTypedBuffer              :: 261;
    MutableRawBuffer                :: 262;

    BaseMask                        :: 255;
    ExtMask                         :: 65280;
}

TypeLayoutReflection :: struct {
    using typelayoutreflection__raw: TypeLayoutReflection__RAW;
    __empty_struct_padding:          u8; // C++ makes empty structs have length 1
}
// TypeLayoutReflection without empty struct padding. Needed to generate a C++-equivalent struct layout when "inheriting" from TypeLayoutReflection
TypeLayoutReflection__RAW :: struct {}

Modifier :: struct {
    using modifier__raw:    Modifier__RAW;
    __empty_struct_padding: u8; // C++ makes empty structs have length 1
}
// Modifier without empty struct padding. Needed to generate a C++-equivalent struct layout when "inheriting" from Modifier
Modifier__RAW :: struct {
    ID :: enum SlangModifierIDIntegral {
        Shared         :: 0;
        NoDiff         :: 1;
        Static         :: 2;
        Const          :: 3;
        Export         :: 4;
        Extern         :: 5;
        Differentiable :: 6;
        Mutating       :: 7;
        In             :: 8;
        Out            :: 9;
        InOut          :: 10;
    }
}

VariableReflection :: struct {
    using variablereflection__raw: VariableReflection__RAW;
    __empty_struct_padding:        u8; // C++ makes empty structs have length 1
}
// VariableReflection without empty struct padding. Needed to generate a C++-equivalent struct layout when "inheriting" from VariableReflection
VariableReflection__RAW :: struct {}

VariableLayoutReflection :: struct {
    using variablelayoutreflection__raw: VariableLayoutReflection__RAW;
    __empty_struct_padding:              u8; // C++ makes empty structs have length 1
}
// VariableLayoutReflection without empty struct padding. Needed to generate a C++-equivalent struct layout when "inheriting" from VariableLayoutReflection
VariableLayoutReflection__RAW :: struct {}

FunctionReflection :: struct {
    using functionreflection__raw: FunctionReflection__RAW;
    __empty_struct_padding:        u8; // C++ makes empty structs have length 1
}
// FunctionReflection without empty struct padding. Needed to generate a C++-equivalent struct layout when "inheriting" from FunctionReflection
FunctionReflection__RAW :: struct {}

GenericReflection :: struct {
    using genericreflection__raw: GenericReflection__RAW;
    __empty_struct_padding:       u8; // C++ makes empty structs have length 1
}
// GenericReflection without empty struct padding. Needed to generate a C++-equivalent struct layout when "inheriting" from GenericReflection
GenericReflection__RAW :: struct {}

EntryPointReflection :: struct {
    using entrypointreflection__raw: EntryPointReflection__RAW;
    __empty_struct_padding:          u8; // C++ makes empty structs have length 1
}
// EntryPointReflection without empty struct padding. Needed to generate a C++-equivalent struct layout when "inheriting" from EntryPointReflection
EntryPointReflection__RAW :: struct {}

EntryPointLayout :: EntryPointReflection;

TypeParameterReflection :: struct {
    using typeparameterreflection__raw: TypeParameterReflection__RAW;
    __empty_struct_padding:             u8; // C++ makes empty structs have length 1
}
// TypeParameterReflection without empty struct padding. Needed to generate a C++-equivalent struct layout when "inheriting" from TypeParameterReflection
TypeParameterReflection__RAW :: struct {}

LayoutRules :: enum SlangLayoutRulesIntegral {
    Default                  :: 0;
    MetalArgumentBufferTier2 :: 1;
}

ProgramLayout :: ShaderReflection;
GenericArgType :: SlangReflectionGenericArgType;

ShaderReflection :: struct {
    using shaderreflection__raw: ShaderReflection__RAW;
    __empty_struct_padding:      u8; // C++ makes empty structs have length 1
}
// ShaderReflection without empty struct padding. Needed to generate a C++-equivalent struct layout when "inheriting" from ShaderReflection
ShaderReflection__RAW :: struct {}

DeclReflection :: struct {
    using declreflection__raw: DeclReflection__RAW;
    __empty_struct_padding:    u8; // C++ makes empty structs have length 1
}
// DeclReflection without empty struct padding. Needed to generate a C++-equivalent struct layout when "inheriting" from DeclReflection
DeclReflection__RAW :: struct {
    Kind :: enum s32 {
        Unsupported :: 0;
        Struct      :: 1;
        Func        :: 2;
        Module      :: 3;
        Generic     :: 4;
        Variable    :: 5;
        Namespace   :: 6;
    }

    FilteredList :: struct(K: Kind) {
        count:  u32;
        parent: *DeclReflection;

        FilteredIterator :: struct {
            parent: *DeclReflection;
            count:  u32;
            index:  u32;
        } #no_padding
    }

    IteratedList :: struct {
        count:  u32;
        parent: *DeclReflection;

        Iterator :: struct {
            parent: *DeclReflection;
            count:  u32;
            index:  u32;
        }
    }
}

CompileCoreModuleFlags :: u32;
CompileCoreModuleFlag :: struct {
    using compilecoremoduleflag__raw: CompileCoreModuleFlag__RAW;
    __empty_struct_padding:           u8; // C++ makes empty structs have length 1
}
// CompileCoreModuleFlag without empty struct padding. Needed to generate a C++-equivalent struct layout when "inheriting" from CompileCoreModuleFlag
CompileCoreModuleFlag__RAW :: struct {
    Enum :: enum CompileCoreModuleFlags {
        WriteDocumentation :: 1;
    }
}

IBlob :: ISlangBlob;

BuiltinModuleName :: enum s32 {
    Core :: 0;
    GLSL :: 1;
}

/** A global session for interaction with the Slang library.

An application may create and re-use a single global session across
multiple sessions, in order to amortize startups costs (in current
Slang this is mostly the cost of loading the Slang standard library).

The global session is currently *not* thread-safe and objects created from
a single global session should only be used from a single thread at
a time.
*/
IGlobalSession :: struct {
    vtable: *IGlobalSession_VTable;
    #place vtable; #as islangunknown: ISlangUnknown; // Support cast to ISlangUnknown
}
IGlobalSession_VTable :: struct #type_info_none {
    using vtable:                       ISlangUnknown_VTable;
    createSession:                      #type (this: *IGlobalSession, desc: *SessionDesc, outSession: **ISession) -> SlangResult #cpp_method;
    findProfile:                        #type (this: *IGlobalSession, name: *u8) -> SlangProfileID #cpp_method;
    setDownstreamCompilerPath:          #type (this: *IGlobalSession, passThrough: SlangPassThrough, path: *u8) -> void #cpp_method;
    setDownstreamCompilerPrelude:       #type (this: *IGlobalSession, passThrough: SlangPassThrough, preludeText: *u8) -> void #cpp_method;
    getDownstreamCompilerPrelude:       #type (this: *IGlobalSession, passThrough: SlangPassThrough, outPrelude: **ISlangBlob) -> void #cpp_method;
    getBuildTagString:                  #type (this: *IGlobalSession) -> *u8 #cpp_method;
    setDefaultDownstreamCompiler:       #type (this: *IGlobalSession, sourceLanguage: SlangSourceLanguage, defaultCompiler: SlangPassThrough) -> SlangResult #cpp_method;
    getDefaultDownstreamCompiler:       #type (this: *IGlobalSession, sourceLanguage: SlangSourceLanguage) -> SlangPassThrough #cpp_method;
    setLanguagePrelude:                 #type (this: *IGlobalSession, sourceLanguage: SlangSourceLanguage, preludeText: *u8) -> void #cpp_method;
    getLanguagePrelude:                 #type (this: *IGlobalSession, sourceLanguage: SlangSourceLanguage, outPrelude: **ISlangBlob) -> void #cpp_method;
    createCompileRequest:               #type (this: *IGlobalSession, outCompileRequest: **ICompileRequest) -> SlangResult #cpp_method;
    addBuiltins:                        #type (this: *IGlobalSession, sourcePath: *u8, sourceString: *u8) -> void #cpp_method;
    setSharedLibraryLoader:             #type (this: *IGlobalSession, loader: *ISlangSharedLibraryLoader) -> void #cpp_method;
    getSharedLibraryLoader:             #type (this: *IGlobalSession) -> *ISlangSharedLibraryLoader #cpp_method;
    checkCompileTargetSupport:          #type (this: *IGlobalSession, target: SlangCompileTarget) -> SlangResult #cpp_method;
    checkPassThroughSupport:            #type (this: *IGlobalSession, passThrough: SlangPassThrough) -> SlangResult #cpp_method;
    compileCoreModule:                  #type (this: *IGlobalSession, flags: CompileCoreModuleFlags) -> SlangResult #cpp_method;
    loadCoreModule:                     #type (this: *IGlobalSession, coreModule: *void, coreModuleSizeInBytes: u64) -> SlangResult #cpp_method;
    saveCoreModule:                     #type (this: *IGlobalSession, archiveType: SlangArchiveType, outBlob: **ISlangBlob) -> SlangResult #cpp_method;
    findCapability:                     #type (this: *IGlobalSession, name: *u8) -> SlangCapabilityID #cpp_method;
    setDownstreamCompilerForTransition: #type (this: *IGlobalSession, source: SlangCompileTarget, target: SlangCompileTarget, compiler: SlangPassThrough) -> void #cpp_method;
    getDownstreamCompilerForTransition: #type (this: *IGlobalSession, source: SlangCompileTarget, target: SlangCompileTarget) -> SlangPassThrough #cpp_method;
    getCompilerElapsedTime:             #type (this: *IGlobalSession, outTotalTime: *float64, outDownstreamTime: *float64) -> void #cpp_method;
    setSPIRVCoreGrammar:                #type (this: *IGlobalSession, jsonPath: *u8) -> SlangResult #cpp_method;
    parseCommandLineArguments:          #type (this: *IGlobalSession, argc: s32, argv: **u8, outSessionDesc: *SessionDesc, outAuxAllocation: **ISlangUnknown) -> SlangResult #cpp_method;
    getSessionDescDigest:               #type (this: *IGlobalSession, sessionDesc: *SessionDesc, outBlob: **ISlangBlob) -> SlangResult #cpp_method;
    compileBuiltinModule:               #type (this: *IGlobalSession, module: BuiltinModuleName, flags: CompileCoreModuleFlags) -> SlangResult #cpp_method;
    loadBuiltinModule:                  #type (this: *IGlobalSession, module: BuiltinModuleName, moduleData: *void, sizeInBytes: u64) -> SlangResult #cpp_method;
    saveBuiltinModule:                  #type (this: *IGlobalSession, module: BuiltinModuleName, archiveType: SlangArchiveType, outBlob: **ISlangBlob) -> SlangResult #cpp_method;
}
IGlobalSession_createSession :: inline (this: *IGlobalSession, desc: *SessionDesc, outSession: **ISession) -> SlangResult { return this.vtable.createSession(this, desc, outSession); }

IGlobalSession_findProfile :: inline (this: *IGlobalSession, name: *u8) -> SlangProfileID { return this.vtable.findProfile(this, name); }

IGlobalSession_setDownstreamCompilerPath :: inline (this: *IGlobalSession, passThrough: SlangPassThrough, path: *u8) { this.vtable.setDownstreamCompilerPath(this, passThrough, path); }

IGlobalSession_setDownstreamCompilerPrelude :: inline (this: *IGlobalSession, passThrough: SlangPassThrough, preludeText: *u8) { this.vtable.setDownstreamCompilerPrelude(this, passThrough, preludeText); }

IGlobalSession_getDownstreamCompilerPrelude :: inline (this: *IGlobalSession, passThrough: SlangPassThrough, outPrelude: **ISlangBlob) { this.vtable.getDownstreamCompilerPrelude(this, passThrough, outPrelude); }

IGlobalSession_getBuildTagString :: inline (this: *IGlobalSession) -> *u8 { return this.vtable.getBuildTagString(this); }

IGlobalSession_setDefaultDownstreamCompiler :: inline (this: *IGlobalSession, sourceLanguage: SlangSourceLanguage, defaultCompiler: SlangPassThrough) -> SlangResult { return this.vtable.setDefaultDownstreamCompiler(this, sourceLanguage, defaultCompiler); }

IGlobalSession_getDefaultDownstreamCompiler :: inline (this: *IGlobalSession, sourceLanguage: SlangSourceLanguage) -> SlangPassThrough { return this.vtable.getDefaultDownstreamCompiler(this, sourceLanguage); }

IGlobalSession_setLanguagePrelude :: inline (this: *IGlobalSession, sourceLanguage: SlangSourceLanguage, preludeText: *u8) { this.vtable.setLanguagePrelude(this, sourceLanguage, preludeText); }

IGlobalSession_getLanguagePrelude :: inline (this: *IGlobalSession, sourceLanguage: SlangSourceLanguage, outPrelude: **ISlangBlob) { this.vtable.getLanguagePrelude(this, sourceLanguage, outPrelude); }

IGlobalSession_createCompileRequest :: inline (this: *IGlobalSession, outCompileRequest: **ICompileRequest) -> SlangResult { return this.vtable.createCompileRequest(this, outCompileRequest); }

IGlobalSession_addBuiltins :: inline (this: *IGlobalSession, sourcePath: *u8, sourceString: *u8) { this.vtable.addBuiltins(this, sourcePath, sourceString); }

IGlobalSession_setSharedLibraryLoader :: inline (this: *IGlobalSession, loader: *ISlangSharedLibraryLoader) { this.vtable.setSharedLibraryLoader(this, loader); }

IGlobalSession_getSharedLibraryLoader :: inline (this: *IGlobalSession) -> *ISlangSharedLibraryLoader { return this.vtable.getSharedLibraryLoader(this); }

IGlobalSession_checkCompileTargetSupport :: inline (this: *IGlobalSession, target: SlangCompileTarget) -> SlangResult { return this.vtable.checkCompileTargetSupport(this, target); }

IGlobalSession_checkPassThroughSupport :: inline (this: *IGlobalSession, passThrough: SlangPassThrough) -> SlangResult { return this.vtable.checkPassThroughSupport(this, passThrough); }

IGlobalSession_compileCoreModule :: inline (this: *IGlobalSession, flags: CompileCoreModuleFlags) -> SlangResult { return this.vtable.compileCoreModule(this, flags); }

IGlobalSession_loadCoreModule :: inline (this: *IGlobalSession, coreModule: *void, coreModuleSizeInBytes: u64) -> SlangResult { return this.vtable.loadCoreModule(this, coreModule, coreModuleSizeInBytes); }

IGlobalSession_saveCoreModule :: inline (this: *IGlobalSession, archiveType: SlangArchiveType, outBlob: **ISlangBlob) -> SlangResult { return this.vtable.saveCoreModule(this, archiveType, outBlob); }

IGlobalSession_findCapability :: inline (this: *IGlobalSession, name: *u8) -> SlangCapabilityID { return this.vtable.findCapability(this, name); }

IGlobalSession_setDownstreamCompilerForTransition :: inline (this: *IGlobalSession, source: SlangCompileTarget, target: SlangCompileTarget, compiler: SlangPassThrough) { this.vtable.setDownstreamCompilerForTransition(this, source, target, compiler); }

IGlobalSession_getDownstreamCompilerForTransition :: inline (this: *IGlobalSession, source: SlangCompileTarget, target: SlangCompileTarget) -> SlangPassThrough { return this.vtable.getDownstreamCompilerForTransition(this, source, target); }

IGlobalSession_getCompilerElapsedTime :: inline (this: *IGlobalSession, outTotalTime: *float64, outDownstreamTime: *float64) { this.vtable.getCompilerElapsedTime(this, outTotalTime, outDownstreamTime); }

IGlobalSession_setSPIRVCoreGrammar :: inline (this: *IGlobalSession, jsonPath: *u8) -> SlangResult { return this.vtable.setSPIRVCoreGrammar(this, jsonPath); }

IGlobalSession_parseCommandLineArguments :: inline (this: *IGlobalSession, argc: s32, argv: **u8, outSessionDesc: *SessionDesc, outAuxAllocation: **ISlangUnknown) -> SlangResult { return this.vtable.parseCommandLineArguments(this, argc, argv, outSessionDesc, outAuxAllocation); }

IGlobalSession_getSessionDescDigest :: inline (this: *IGlobalSession, sessionDesc: *SessionDesc, outBlob: **ISlangBlob) -> SlangResult { return this.vtable.getSessionDescDigest(this, sessionDesc, outBlob); }

IGlobalSession_compileBuiltinModule :: inline (this: *IGlobalSession, module: BuiltinModuleName, flags: CompileCoreModuleFlags) -> SlangResult { return this.vtable.compileBuiltinModule(this, module, flags); }

IGlobalSession_loadBuiltinModule :: inline (this: *IGlobalSession, module: BuiltinModuleName, moduleData: *void, sizeInBytes: u64) -> SlangResult { return this.vtable.loadBuiltinModule(this, module, moduleData, sizeInBytes); }

IGlobalSession_saveBuiltinModule :: inline (this: *IGlobalSession, module: BuiltinModuleName, archiveType: SlangArchiveType, outBlob: **ISlangBlob) -> SlangResult { return this.vtable.saveBuiltinModule(this, module, archiveType, outBlob); }

vtable :: (obj: *IGlobalSession) -> *IGlobalSession_VTable { return obj.vtable; }


/** Description of a code generation target.
*/
TargetDesc :: struct {
    /** The size of this structure, in bytes.
    */
    structureSize:               u64 = 48;

    /** The target format to generate code for (e.g., SPIR-V, DXIL, etc.)
    */
    format:                      SlangCompileTarget = .TARGET_UNKNOWN;

    /** The compilation profile supported by the target (e.g., "Shader Model 5.1")
    */
    profile:                     SlangProfileID = .SLANG_PROFILE_UNKNOWN;

    /** Flags for the code generation target. Currently unused. */
    flags:                       SlangTargetFlags = kDefaultTargetFlags;

    /** Default mode to use for floating-point operations on the target.
    */
    floatingPointMode:           SlangFloatingPointMode = .DEFAULT;

    /** The line directive mode for output source code.
    */
    lineDirectiveMode:           SlangLineDirectiveMode = .DEFAULT;

    /** Whether to force `scalar` layout for glsl shader storage buffers.
    */
    forceGLSLScalarBufferLayout  := false;

    /** Pointer to an array of compiler option entries, whose size is compilerOptionEntryCount.
    */
    compilerOptionEntries:       *CompilerOptionEntry = null;

    /** Number of additional compiler option entries.
    */
    compilerOptionEntryCount:    u32 = 0;
}

SessionFlags :: u32;
anon_enum_1 :: enum s32 {
    kSessionFlags_None :: 0;
}

PreprocessorMacroDesc :: struct {
    name:  *u8;
    value: *u8;
}

SessionDesc :: struct {
    /** The size of this structure, in bytes.
    */
    structureSize:            u64 = 96;

    /** Code generation targets to include in the session.
    */
    targets:                  *TargetDesc = null;
    targetCount:              SlangInt = 0;

    /** Flags to configure the session.
    */
    flags:                    SessionFlags = xx anon_enum_1.kSessionFlags_None;

    /** Default layout to assume for variables with matrix types.
    */
    defaultMatrixLayoutMode:  SlangMatrixLayoutMode = .ROW_MAJOR;

    /** Paths to use when searching for `#include`d or `import`ed files.
    */
    searchPaths:              **u8 = null;
    searchPathCount:          SlangInt = 0;

    preprocessorMacros:       *PreprocessorMacroDesc = null;
    preprocessorMacroCount:   SlangInt = 0;

    fileSystem:               *ISlangFileSystem = null;

    enableEffectAnnotations   := false;
    allowGLSLSyntax           := false;

    /** Pointer to an array of compiler option entries, whose size is compilerOptionEntryCount.
    */
    compilerOptionEntries:    *CompilerOptionEntry = null;

    /** Number of additional compiler option entries.
    */
    compilerOptionEntryCount: u32 = 0;

    /** Whether to skip SPIRV validation.
    */
    skipSPIRVValidation       := false;
}

ContainerType :: enum s32 {
    None             :: 0;
    UnsizedArray     :: 1;
    StructuredBuffer :: 2;
    ConstantBuffer   :: 3;
    ParameterBlock   :: 4;
}

/** A session provides a scope for code that is loaded.

A session can be used to load modules of Slang source code,
and to request target-specific compiled binaries and layout
information.

In order to be able to load code, the session owns a set
of active "search paths" for resolving `#include` directives
and `import` declarations, as well as a set of global
preprocessor definitions that will be used for all code
that gets `import`ed in the session.

If multiple user shaders are loaded in the same session,
and import the same module (e.g., two source files do `import X`)
then there will only be one copy of `X` loaded within the session.

In order to be able to generate target code, the session
owns a list of available compilation targets, which specify
code generation options.

Code loaded and compiled within a session is owned by the session
and will remain resident in memory until the session is released.
Applications wishing to control the memory usage for compiled
and loaded code should use multiple sessions.
*/
ISession :: struct {
    vtable: *ISession_VTable;
    #place vtable; #as islangunknown: ISlangUnknown; // Support cast to ISlangUnknown
}
ISession_VTable :: struct #type_info_none {
    using vtable:                          ISlangUnknown_VTable;
    getGlobalSession:                      #type (this: *ISession) -> *IGlobalSession #cpp_method;
    loadModule:                            #type (this: *ISession, moduleName: *u8, outDiagnostics: **IBlob = null) -> *IModule #cpp_method;
    loadModuleFromSource:                  #type (this: *ISession, moduleName: *u8, path: *u8, source: *IBlob, outDiagnostics: **IBlob = null) -> *IModule #cpp_method;
    createCompositeComponentType:          #type (this: *ISession, componentTypes: **IComponentType, componentTypeCount: SlangInt, outCompositeComponentType: **IComponentType, outDiagnostics: **ISlangBlob = null) -> SlangResult #cpp_method;
    specializeType:                        #type (this: *ISession, type: *TypeReflection, specializationArgs: *SpecializationArg, specializationArgCount: SlangInt, outDiagnostics: **ISlangBlob = null) -> *TypeReflection #cpp_method;
    getTypeLayout:                         #type (this: *ISession, type: *TypeReflection, targetIndex: SlangInt = 0, rules: LayoutRules = .Default, outDiagnostics: **ISlangBlob = null) -> *TypeLayoutReflection #cpp_method;
    getContainerType:                      #type (this: *ISession, elementType: *TypeReflection, containerType: ContainerType, outDiagnostics: **ISlangBlob = null) -> *TypeReflection #cpp_method;
    getDynamicType:                        #type (this: *ISession) -> *TypeReflection #cpp_method;
    getTypeRTTIMangledName:                #type (this: *ISession, type: *TypeReflection, outNameBlob: **ISlangBlob) -> SlangResult #cpp_method;
    getTypeConformanceWitnessMangledName:  #type (this: *ISession, type: *TypeReflection, interfaceType: *TypeReflection, outNameBlob: **ISlangBlob) -> SlangResult #cpp_method;
    getTypeConformanceWitnessSequentialID: #type (this: *ISession, type: *TypeReflection, interfaceType: *TypeReflection, outId: *u32) -> SlangResult #cpp_method;
    createCompileRequest:                  #type (this: *ISession, outCompileRequest: **SlangCompileRequest) -> SlangResult #cpp_method;
    createTypeConformanceComponentType:    #type (this: *ISession, type: *TypeReflection, interfaceType: *TypeReflection, outConformance: **ITypeConformance, conformanceIdOverride: SlangInt, outDiagnostics: **ISlangBlob) -> SlangResult #cpp_method;
    loadModuleFromIRBlob:                  #type (this: *ISession, moduleName: *u8, path: *u8, source: *IBlob, outDiagnostics: **IBlob = null) -> *IModule #cpp_method;
    getLoadedModuleCount:                  #type (this: *ISession) -> SlangInt #cpp_method;
    getLoadedModule:                       #type (this: *ISession, index: SlangInt) -> *IModule #cpp_method;
    isBinaryModuleUpToDate:                #type (this: *ISession, modulePath: *u8, binaryModuleBlob: *IBlob) -> bool #cpp_method;
    loadModuleFromSourceString:            #type (this: *ISession, moduleName: *u8, path: *u8, _string: *u8, outDiagnostics: **IBlob = null) -> *IModule #cpp_method;
    getDynamicObjectRTTIBytes:             #type (this: *ISession, type: *TypeReflection, interfaceType: *TypeReflection, outRTTIDataBuffer: *u32, bufferSizeInBytes: u32) -> SlangResult #cpp_method;
    loadModuleInfoFromIRBlob:              #type (this: *ISession, source: *IBlob, outModuleVersion: *SlangInt, outModuleCompilerVersion: **u8, outModuleName: **u8) -> SlangResult #cpp_method;
}
ISession_getGlobalSession :: inline (this: *ISession) -> *IGlobalSession { return this.vtable.getGlobalSession(this); }

ISession_loadModule :: inline (this: *ISession, moduleName: *u8, outDiagnostics: **IBlob = null) -> *IModule { return this.vtable.loadModule(this, moduleName, outDiagnostics); }

ISession_loadModuleFromSource :: inline (this: *ISession, moduleName: *u8, path: *u8, source: *IBlob, outDiagnostics: **IBlob = null) -> *IModule { return this.vtable.loadModuleFromSource(this, moduleName, path, source, outDiagnostics); }

ISession_createCompositeComponentType :: inline (this: *ISession, componentTypes: **IComponentType, componentTypeCount: SlangInt, outCompositeComponentType: **IComponentType, outDiagnostics: **ISlangBlob = null) -> SlangResult { return this.vtable.createCompositeComponentType(this, componentTypes, componentTypeCount, outCompositeComponentType, outDiagnostics); }

ISession_specializeType :: inline (this: *ISession, type: *TypeReflection, specializationArgs: *SpecializationArg, specializationArgCount: SlangInt, outDiagnostics: **ISlangBlob = null) -> *TypeReflection { return this.vtable.specializeType(this, type, specializationArgs, specializationArgCount, outDiagnostics); }

ISession_getTypeLayout :: inline (this: *ISession, type: *TypeReflection, targetIndex: SlangInt = 0, rules: LayoutRules = .Default, outDiagnostics: **ISlangBlob = null) -> *TypeLayoutReflection { return this.vtable.getTypeLayout(this, type, targetIndex, rules, outDiagnostics); }

ISession_getContainerType :: inline (this: *ISession, elementType: *TypeReflection, containerType: ContainerType, outDiagnostics: **ISlangBlob = null) -> *TypeReflection { return this.vtable.getContainerType(this, elementType, containerType, outDiagnostics); }

ISession_getDynamicType :: inline (this: *ISession) -> *TypeReflection { return this.vtable.getDynamicType(this); }

ISession_getTypeRTTIMangledName :: inline (this: *ISession, type: *TypeReflection, outNameBlob: **ISlangBlob) -> SlangResult { return this.vtable.getTypeRTTIMangledName(this, type, outNameBlob); }

ISession_getTypeConformanceWitnessMangledName :: inline (this: *ISession, type: *TypeReflection, interfaceType: *TypeReflection, outNameBlob: **ISlangBlob) -> SlangResult { return this.vtable.getTypeConformanceWitnessMangledName(this, type, interfaceType, outNameBlob); }

ISession_getTypeConformanceWitnessSequentialID :: inline (this: *ISession, type: *TypeReflection, interfaceType: *TypeReflection, outId: *u32) -> SlangResult { return this.vtable.getTypeConformanceWitnessSequentialID(this, type, interfaceType, outId); }

ISession_createCompileRequest :: inline (this: *ISession, outCompileRequest: **SlangCompileRequest) -> SlangResult { return this.vtable.createCompileRequest(this, outCompileRequest); }

ISession_createTypeConformanceComponentType :: inline (this: *ISession, type: *TypeReflection, interfaceType: *TypeReflection, outConformance: **ITypeConformance, conformanceIdOverride: SlangInt, outDiagnostics: **ISlangBlob) -> SlangResult { return this.vtable.createTypeConformanceComponentType(this, type, interfaceType, outConformance, conformanceIdOverride, outDiagnostics); }

ISession_loadModuleFromIRBlob :: inline (this: *ISession, moduleName: *u8, path: *u8, source: *IBlob, outDiagnostics: **IBlob = null) -> *IModule { return this.vtable.loadModuleFromIRBlob(this, moduleName, path, source, outDiagnostics); }

ISession_getLoadedModuleCount :: inline (this: *ISession) -> SlangInt { return this.vtable.getLoadedModuleCount(this); }
ISession_getLoadedModule :: inline (this: *ISession, index: SlangInt) -> *IModule { return this.vtable.getLoadedModule(this, index); }

ISession_isBinaryModuleUpToDate :: inline (this: *ISession, modulePath: *u8, binaryModuleBlob: *IBlob) -> bool { return this.vtable.isBinaryModuleUpToDate(this, modulePath, binaryModuleBlob); }

ISession_loadModuleFromSourceString :: inline (this: *ISession, moduleName: *u8, path: *u8, _string: *u8, outDiagnostics: **IBlob = null) -> *IModule { return this.vtable.loadModuleFromSourceString(this, moduleName, path, _string, outDiagnostics); }

ISession_getDynamicObjectRTTIBytes :: inline (this: *ISession, type: *TypeReflection, interfaceType: *TypeReflection, outRTTIDataBuffer: *u32, bufferSizeInBytes: u32) -> SlangResult { return this.vtable.getDynamicObjectRTTIBytes(this, type, interfaceType, outRTTIDataBuffer, bufferSizeInBytes); }

ISession_loadModuleInfoFromIRBlob :: inline (this: *ISession, source: *IBlob, outModuleVersion: *SlangInt, outModuleCompilerVersion: **u8, outModuleName: **u8) -> SlangResult { return this.vtable.loadModuleInfoFromIRBlob(this, source, outModuleVersion, outModuleCompilerVersion, outModuleName); }

vtable :: (obj: *ISession) -> *ISession_VTable { return obj.vtable; }


IMetadata :: struct {
    vtable: *IMetadata_VTable;
    #place vtable; #as islangcastable: ISlangCastable; // Support cast to ISlangCastable
}
IMetadata_VTable :: struct #type_info_none {
    using,except(vtable) vtable:                  ISlangCastable_VTable;
    isParameterLocationUsed: #type (this: *IMetadata, category: SlangParameterCategory, spaceIndex: SlangUInt, registerIndex: SlangUInt, outUsed: *bool) -> SlangResult #cpp_method;
    getDebugBuildIdentifier: #type (this: *IMetadata) -> *u8 #cpp_method;
}
IMetadata_isParameterLocationUsed :: inline (this: *IMetadata, category: SlangParameterCategory, spaceIndex: SlangUInt, registerIndex: SlangUInt, outUsed: *bool) -> SlangResult { return this.vtable.isParameterLocationUsed(this, category, spaceIndex, registerIndex, outUsed); }

IMetadata_getDebugBuildIdentifier :: inline (this: *IMetadata) -> *u8 { return this.vtable.getDebugBuildIdentifier(this); }

vtable :: (obj: *IMetadata) -> *IMetadata_VTable { return obj.vtable; }


/** Compile result for storing and retrieving multiple output blobs.
This is needed for features such as separate debug compilation which
output both base and debug spirv.
*/
ICompileResult :: struct {
    vtable: *ICompileResult_VTable;
    #place vtable; #as islangcastable: ISlangCastable; // Support cast to ISlangCastable
}
ICompileResult_VTable :: struct #type_info_none {
    using,except(vtable) vtable:       ISlangCastable_VTable;
    getItemCount: #type (this: *ICompileResult) -> u32 #cpp_method;
    getItemData:  #type (this: *ICompileResult, index: u32, outblob: **IBlob) -> SlangResult #cpp_method;
    getMetadata:  #type (this: *ICompileResult, outMetadata: **IMetadata) -> SlangResult #cpp_method;
}
ICompileResult_getItemCount :: inline (this: *ICompileResult) -> u32 { return this.vtable.getItemCount(this); }
ICompileResult_getItemData :: inline (this: *ICompileResult, index: u32, outblob: **IBlob) -> SlangResult { return this.vtable.getItemData(this, index, outblob); }
ICompileResult_getMetadata :: inline (this: *ICompileResult, outMetadata: **IMetadata) -> SlangResult { return this.vtable.getMetadata(this, outMetadata); }

vtable :: (obj: *ICompileResult) -> *ICompileResult_VTable { return obj.vtable; }


/** A component type is a unit of shader code layout, reflection, and linking.

A component type is a unit of shader code that can be included into
a linked and compiled shader program. Each component type may have:

* Zero or more uniform shader parameters, representing textures,
buffers, etc. that the code in the component depends on.

* Zero or more *specialization* parameters, which are type or
value parameters that can be used to synthesize specialized
versions of the component type.

* Zero or more entry points, which are the individually invocable
kernels that can have final code generated.

* Zero or more *requirements*, which are other component
types on which the component type depends.

One example of a component type is a module of Slang code:

* The global-scope shader parameters declared in the module are
the parameters when considered as a component type.

* Any global-scope generic or interface type parameters introduce
specialization parameters for the module.

* A module does not by default include any entry points when
considered as a component type (although the code of the
module might *declare* some entry points).

* Any other modules that are `import`ed in the source code
become requirements of the module, when considered as a
component type.

An entry point is another example of a component type:

* The `uniform` parameters of the entry point function are
its shader parameters when considered as a component type.

* Any generic or interface-type parameters of the entry point
introduce specialization parameters.

* An entry point component type exposes a single entry point (itself).

* An entry point has one requirement for the module in which
it was defined.

Component types can be manipulated in a few ways:

* Multiple component types can be combined into a composite, which
combines all of their code, parameters, etc.

* A component type can be specialized, by "plugging in" types and
values for its specialization parameters.

* A component type can be laid out for a particular target, giving
offsets/bindings to the shader parameters it contains.

* Generated kernel code can be requested for entry points.

*/
IComponentType :: struct {
    vtable: *IComponentType_VTable;
    #place vtable; #as islangunknown: ISlangUnknown; // Support cast to ISlangUnknown
}
IComponentType_VTable :: struct #type_info_none {
    using vtable:                ISlangUnknown_VTable;
    getSession:                  #type (this: *IComponentType) -> *ISession #cpp_method;
    getLayout:                   #type (this: *IComponentType, targetIndex: SlangInt = 0, outDiagnostics: **IBlob = null) -> *ProgramLayout #cpp_method;
    getSpecializationParamCount: #type (this: *IComponentType) -> SlangInt #cpp_method;
    getEntryPointCode:           #type (this: *IComponentType, entryPointIndex: SlangInt, targetIndex: SlangInt, outCode: **IBlob, outDiagnostics: **IBlob = null) -> SlangResult #cpp_method;
    getResultAsFileSystem:       #type (this: *IComponentType, entryPointIndex: SlangInt, targetIndex: SlangInt, outFileSystem: **ISlangMutableFileSystem) -> SlangResult #cpp_method;
    getEntryPointHash:           #type (this: *IComponentType, entryPointIndex: SlangInt, targetIndex: SlangInt, outHash: **IBlob) -> void #cpp_method;
    specialize:                  #type (this: *IComponentType, specializationArgs: *SpecializationArg, specializationArgCount: SlangInt, outSpecializedComponentType: **IComponentType, outDiagnostics: **ISlangBlob = null) -> SlangResult #cpp_method;
    link:                        #type (this: *IComponentType, outLinkedComponentType: **IComponentType, outDiagnostics: **ISlangBlob = null) -> SlangResult #cpp_method;
    getEntryPointHostCallable:   #type (this: *IComponentType, entryPointIndex: s32, targetIndex: s32, outSharedLibrary: **ISlangSharedLibrary, outDiagnostics: **IBlob = null) -> SlangResult #cpp_method;
    renameEntryPoint:            #type (this: *IComponentType, newName: *u8, outEntryPoint: **IComponentType) -> SlangResult #cpp_method;
    linkWithOptions:             #type (this: *IComponentType, outLinkedComponentType: **IComponentType, compilerOptionEntryCount: u32, compilerOptionEntries: *CompilerOptionEntry, outDiagnostics: **ISlangBlob = null) -> SlangResult #cpp_method;
    getTargetCode:               #type (this: *IComponentType, targetIndex: SlangInt, outCode: **IBlob, outDiagnostics: **IBlob = null) -> SlangResult #cpp_method;
    getTargetMetadata:           #type (this: *IComponentType, targetIndex: SlangInt, outMetadata: **IMetadata, outDiagnostics: **IBlob = null) -> SlangResult #cpp_method;
    getEntryPointMetadata:       #type (this: *IComponentType, entryPointIndex: SlangInt, targetIndex: SlangInt, outMetadata: **IMetadata, outDiagnostics: **IBlob = null) -> SlangResult #cpp_method;
}
IComponentType_getSession :: inline (this: *IComponentType) -> *ISession { return this.vtable.getSession(this); }

IComponentType_getLayout :: inline (this: *IComponentType, targetIndex: SlangInt = 0, outDiagnostics: **IBlob = null) -> *ProgramLayout { return this.vtable.getLayout(this, targetIndex, outDiagnostics); }

IComponentType_getSpecializationParamCount :: inline (this: *IComponentType) -> SlangInt { return this.vtable.getSpecializationParamCount(this); }

IComponentType_getEntryPointCode :: inline (this: *IComponentType, entryPointIndex: SlangInt, targetIndex: SlangInt, outCode: **IBlob, outDiagnostics: **IBlob = null) -> SlangResult { return this.vtable.getEntryPointCode(this, entryPointIndex, targetIndex, outCode, outDiagnostics); }

IComponentType_getResultAsFileSystem :: inline (this: *IComponentType, entryPointIndex: SlangInt, targetIndex: SlangInt, outFileSystem: **ISlangMutableFileSystem) -> SlangResult { return this.vtable.getResultAsFileSystem(this, entryPointIndex, targetIndex, outFileSystem); }

IComponentType_getEntryPointHash :: inline (this: *IComponentType, entryPointIndex: SlangInt, targetIndex: SlangInt, outHash: **IBlob) { this.vtable.getEntryPointHash(this, entryPointIndex, targetIndex, outHash); }

IComponentType_specialize :: inline (this: *IComponentType, specializationArgs: *SpecializationArg, specializationArgCount: SlangInt, outSpecializedComponentType: **IComponentType, outDiagnostics: **ISlangBlob = null) -> SlangResult { return this.vtable.specialize(this, specializationArgs, specializationArgCount, outSpecializedComponentType, outDiagnostics); }

IComponentType_link :: inline (this: *IComponentType, outLinkedComponentType: **IComponentType, outDiagnostics: **ISlangBlob = null) -> SlangResult { return this.vtable.link(this, outLinkedComponentType, outDiagnostics); }

IComponentType_getEntryPointHostCallable :: inline (this: *IComponentType, entryPointIndex: s32, targetIndex: s32, outSharedLibrary: **ISlangSharedLibrary, outDiagnostics: **IBlob = null) -> SlangResult { return this.vtable.getEntryPointHostCallable(this, entryPointIndex, targetIndex, outSharedLibrary, outDiagnostics); }

IComponentType_renameEntryPoint :: inline (this: *IComponentType, newName: *u8, outEntryPoint: **IComponentType) -> SlangResult { return this.vtable.renameEntryPoint(this, newName, outEntryPoint); }

IComponentType_linkWithOptions :: inline (this: *IComponentType, outLinkedComponentType: **IComponentType, compilerOptionEntryCount: u32, compilerOptionEntries: *CompilerOptionEntry, outDiagnostics: **ISlangBlob = null) -> SlangResult { return this.vtable.linkWithOptions(this, outLinkedComponentType, compilerOptionEntryCount, compilerOptionEntries, outDiagnostics); }

IComponentType_getTargetCode :: inline (this: *IComponentType, targetIndex: SlangInt, outCode: **IBlob, outDiagnostics: **IBlob = null) -> SlangResult { return this.vtable.getTargetCode(this, targetIndex, outCode, outDiagnostics); }

IComponentType_getTargetMetadata :: inline (this: *IComponentType, targetIndex: SlangInt, outMetadata: **IMetadata, outDiagnostics: **IBlob = null) -> SlangResult { return this.vtable.getTargetMetadata(this, targetIndex, outMetadata, outDiagnostics); }

IComponentType_getEntryPointMetadata :: inline (this: *IComponentType, entryPointIndex: SlangInt, targetIndex: SlangInt, outMetadata: **IMetadata, outDiagnostics: **IBlob = null) -> SlangResult { return this.vtable.getEntryPointMetadata(this, entryPointIndex, targetIndex, outMetadata, outDiagnostics); }

vtable :: (obj: *IComponentType) -> *IComponentType_VTable { return obj.vtable; }


IEntryPoint :: struct {
    vtable: *IEntryPoint_VTable;
    #place vtable; #as icomponenttype: IComponentType; // Support cast to IComponentType
}
IEntryPoint_VTable :: struct #type_info_none {
    using,except(vtable) vtable:                IComponentType_VTable;
    getFunctionReflection: #type (this: *IEntryPoint) -> *FunctionReflection #cpp_method;
}
IEntryPoint_getFunctionReflection :: inline (this: *IEntryPoint) -> *FunctionReflection { return this.vtable.getFunctionReflection(this); }

vtable :: (obj: *IEntryPoint) -> *IEntryPoint_VTable { return obj.vtable; }


ITypeConformance :: struct {
    vtable: *IComponentType_VTable;
    #place vtable; #as icomponenttype: IComponentType; // Support cast to IComponentType
}

/** IComponentType2 is a component type used for getting separate debug data.

This interface is used for getting separate debug data, introduced here to
avoid breaking backwards compatibility of the IComponentType interface.

The `getTargetCompileResult` and `getEntryPointCompileResult` functions
are used to get the base and debug spirv, and metadata containing the
debug build identifier.
*/
IComponentType2 :: struct {
    vtable: *IComponentType2_VTable;
    #place vtable; #as islangunknown: ISlangUnknown; // Support cast to ISlangUnknown
}
IComponentType2_VTable :: struct #type_info_none {
    using vtable:               ISlangUnknown_VTable;
    getTargetCompileResult:     #type (this: *IComponentType2, targetIndex: SlangInt, outCompileResult: **ICompileResult, outDiagnostics: **IBlob = null) -> SlangResult #cpp_method;
    getEntryPointCompileResult: #type (this: *IComponentType2, entryPointIndex: SlangInt, targetIndex: SlangInt, outCompileResult: **ICompileResult, outDiagnostics: **IBlob = null) -> SlangResult #cpp_method;
}
IComponentType2_getTargetCompileResult :: inline (this: *IComponentType2, targetIndex: SlangInt, outCompileResult: **ICompileResult, outDiagnostics: **IBlob = null) -> SlangResult { return this.vtable.getTargetCompileResult(this, targetIndex, outCompileResult, outDiagnostics); }

IComponentType2_getEntryPointCompileResult :: inline (this: *IComponentType2, entryPointIndex: SlangInt, targetIndex: SlangInt, outCompileResult: **ICompileResult, outDiagnostics: **IBlob = null) -> SlangResult { return this.vtable.getEntryPointCompileResult(this, entryPointIndex, targetIndex, outCompileResult, outDiagnostics); }

vtable :: (obj: *IComponentType2) -> *IComponentType2_VTable { return obj.vtable; }


/** A module is the granularity of shader code compilation and loading.

In most cases a module corresponds to a single compile "translation unit."
This will often be a single `.slang` or `.hlsl` file and everything it
`#include`s.

Notably, a module `M` does *not* include the things it `import`s, as these
as distinct modules that `M` depends on. There is a directed graph of
module dependencies, and all modules in the graph must belong to the
same session (`ISession`).

A module establishes a namespace for looking up types, functions, etc.
*/
IModule :: struct {
    vtable: *IModule_VTable;
    #place vtable; #as icomponenttype: IComponentType; // Support cast to IComponentType
}
IModule_VTable :: struct #type_info_none {
    using,except(vtable) vtable:                    IComponentType_VTable;
    findEntryPointByName:      #type (this: *IModule, name: *u8, outEntryPoint: **IEntryPoint) -> SlangResult #cpp_method;
    getDefinedEntryPointCount: #type (this: *IModule) -> SlangInt32 #cpp_method;
    getDefinedEntryPoint:      #type (this: *IModule, index: SlangInt32, outEntryPoint: **IEntryPoint) -> SlangResult #cpp_method;
    serialize:                 #type (this: *IModule, outSerializedBlob: **ISlangBlob) -> SlangResult #cpp_method;
    writeToFile:               #type (this: *IModule, fileName: *u8) -> SlangResult #cpp_method;
    getName:                   #type (this: *IModule) -> *u8 #cpp_method;
    getFilePath:               #type (this: *IModule) -> *u8 #cpp_method;
    getUniqueIdentity:         #type (this: *IModule) -> *u8 #cpp_method;
    findAndCheckEntryPoint:    #type (this: *IModule, name: *u8, stage: SlangStage, outEntryPoint: **IEntryPoint, outDiagnostics: **ISlangBlob) -> SlangResult #cpp_method;
    getDependencyFileCount:    #type (this: *IModule) -> SlangInt32 #cpp_method;
    getDependencyFilePath:     #type (this: *IModule, index: SlangInt32) -> *u8 #cpp_method;
    getModuleReflection:       #type (this: *IModule) -> *DeclReflection #cpp_method;
    disassemble:               #type (this: *IModule, outDisassembledBlob: **IBlob) -> SlangResult #cpp_method;
}
IModule_findEntryPointByName :: inline (this: *IModule, name: *u8, outEntryPoint: **IEntryPoint) -> SlangResult { return this.vtable.findEntryPointByName(this, name, outEntryPoint); }

IModule_getDefinedEntryPointCount :: inline (this: *IModule) -> SlangInt32 { return this.vtable.getDefinedEntryPointCount(this); }

IModule_getDefinedEntryPoint :: inline (this: *IModule, index: SlangInt32, outEntryPoint: **IEntryPoint) -> SlangResult { return this.vtable.getDefinedEntryPoint(this, index, outEntryPoint); }

IModule_serialize :: inline (this: *IModule, outSerializedBlob: **ISlangBlob) -> SlangResult { return this.vtable.serialize(this, outSerializedBlob); }

IModule_writeToFile :: inline (this: *IModule, fileName: *u8) -> SlangResult { return this.vtable.writeToFile(this, fileName); }

IModule_getName :: inline (this: *IModule) -> *u8 { return this.vtable.getName(this); }

IModule_getFilePath :: inline (this: *IModule) -> *u8 { return this.vtable.getFilePath(this); }

IModule_getUniqueIdentity :: inline (this: *IModule) -> *u8 { return this.vtable.getUniqueIdentity(this); }

IModule_findAndCheckEntryPoint :: inline (this: *IModule, name: *u8, stage: SlangStage, outEntryPoint: **IEntryPoint, outDiagnostics: **ISlangBlob) -> SlangResult { return this.vtable.findAndCheckEntryPoint(this, name, stage, outEntryPoint, outDiagnostics); }

IModule_getDependencyFileCount :: inline (this: *IModule) -> SlangInt32 { return this.vtable.getDependencyFileCount(this); }

IModule_getDependencyFilePath :: inline (this: *IModule, index: SlangInt32) -> *u8 { return this.vtable.getDependencyFilePath(this, index); }

IModule_getModuleReflection :: inline (this: *IModule) -> *DeclReflection { return this.vtable.getModuleReflection(this); }

IModule_disassemble :: inline (this: *IModule, outDisassembledBlob: **IBlob) -> SlangResult { return this.vtable.disassemble(this, outDisassembledBlob); }

vtable :: (obj: *IModule) -> *IModule_VTable { return obj.vtable; }


/* Experimental interface for doing target precompilation of slang modules */
IModulePrecompileService_Experimental :: struct {
    vtable: *IModulePrecompileService_Experimental_VTable;
    #place vtable; #as islangunknown: ISlangUnknown; // Support cast to ISlangUnknown
}
IModulePrecompileService_Experimental_VTable :: struct #type_info_none {
    using vtable:             ISlangUnknown_VTable;
    precompileForTarget:      #type (this: *IModulePrecompileService_Experimental, target: SlangCompileTarget, outDiagnostics: **ISlangBlob) -> SlangResult #cpp_method;
    getPrecompiledTargetCode: #type (this: *IModulePrecompileService_Experimental, target: SlangCompileTarget, outCode: **IBlob, outDiagnostics: **IBlob = null) -> SlangResult #cpp_method;
    getModuleDependencyCount: #type (this: *IModulePrecompileService_Experimental) -> SlangInt #cpp_method;
    getModuleDependency:      #type (this: *IModulePrecompileService_Experimental, dependencyIndex: SlangInt, outModule: **IModule, outDiagnostics: **IBlob = null) -> SlangResult #cpp_method;
}
IModulePrecompileService_Experimental_precompileForTarget :: inline (this: *IModulePrecompileService_Experimental, target: SlangCompileTarget, outDiagnostics: **ISlangBlob) -> SlangResult { return this.vtable.precompileForTarget(this, target, outDiagnostics); }

IModulePrecompileService_Experimental_getPrecompiledTargetCode :: inline (this: *IModulePrecompileService_Experimental, target: SlangCompileTarget, outCode: **IBlob, outDiagnostics: **IBlob = null) -> SlangResult { return this.vtable.getPrecompiledTargetCode(this, target, outCode, outDiagnostics); }

IModulePrecompileService_Experimental_getModuleDependencyCount :: inline (this: *IModulePrecompileService_Experimental) -> SlangInt { return this.vtable.getModuleDependencyCount(this); }

IModulePrecompileService_Experimental_getModuleDependency :: inline (this: *IModulePrecompileService_Experimental, dependencyIndex: SlangInt, outModule: **IModule, outDiagnostics: **IBlob = null) -> SlangResult { return this.vtable.getModuleDependency(this, dependencyIndex, outModule, outDiagnostics); }

vtable :: (obj: *IModulePrecompileService_Experimental) -> *IModulePrecompileService_Experimental_VTable { return obj.vtable; }


/** Argument used for specialization to types/values.
*/
SpecializationArg :: struct {
    Kind :: enum s32 {
        Unknown :: 0;
        Type    :: 1;
    }

    /** The kind of specialization argument. */
    kind: Kind;
    union {
        /** A type specialization argument, used for `Kind::Type`. */
        type: *TypeReflection;
    }
}

OperandDataType :: enum s32 {
    General :: 0;
    Int32   :: 1;
    Int64   :: 2;
    Float32 :: 3;
    Float64 :: 4;
    String  :: 5;
}

VMExecOperand :: struct {
    section:    **u8; // Pointer to the section start pointer.

    __bitfield: u32;
    /* 
        type: u32; /* 8 bits */ // type of the operand data.
        size: u32; /* 24 bits */;
    */

    offset:     u32;
}

VMExtFunction :: #type (_context: *IByteCodeRunner, inst: *VMExecInstHeader, userData: *void) -> void #c_call;
VMPrintFunc :: #type (message: *u8, userData: *void) -> void #c_call;

VMExecInstHeader :: struct {
    functionPtr:     VMExtFunction; // Pointer to the function that executes this instruction.

    opcodeExtension: u32;
    operandCount:    u32;
}

ByteCodeFuncInfo :: struct {
    parameterCount:  u32;
    returnValueSize: u32;
}

ByteCodeRunnerDesc :: struct {
    /** The size of this structure, in bytes.
    */
    structSize: u64 = 8;
}

/// Represents a byte code runner that can execute Slang byte code.
IByteCodeRunner :: struct {
    vtable: *IByteCodeRunner_VTable;
    #place vtable; #as islangunknown: ISlangUnknown; // Support cast to ISlangUnknown
}
IByteCodeRunner_VTable :: struct #type_info_none {
    using vtable:              ISlangUnknown_VTable;
    loadModule:                #type (this: *IByteCodeRunner, moduleBlob: *IBlob) -> SlangResult #cpp_method;
    selectFunctionByIndex:     #type (this: *IByteCodeRunner, functionIndex: u32) -> SlangResult #cpp_method;
    findFunctionByName:        #type (this: *IByteCodeRunner, name: *u8) -> s32 #cpp_method;
    getFunctionInfo:           #type (this: *IByteCodeRunner, index: u32, outInfo: *ByteCodeFuncInfo) -> SlangResult #cpp_method;
    getCurrentWorkingSet:      #type (this: *IByteCodeRunner) -> *void #cpp_method;
    execute:                   #type (this: *IByteCodeRunner, argumentData: *void, argumentSize: u64) -> SlangResult #cpp_method;
    getErrorString:            #type (this: *IByteCodeRunner, outBlob: **IBlob) -> void #cpp_method;
    getReturnValue:            #type (this: *IByteCodeRunner, outValueSize: *u64) -> *void #cpp_method;
    setExtInstHandlerUserData: #type (this: *IByteCodeRunner, userData: *void) -> void #cpp_method;
    registerExtCall:           #type (this: *IByteCodeRunner, name: *u8, functionPtr: VMExtFunction) -> SlangResult #cpp_method;
    setPrintCallback:          #type (this: *IByteCodeRunner, callback: VMPrintFunc, userData: *void) -> SlangResult #cpp_method;
}
IByteCodeRunner_loadModule :: inline (this: *IByteCodeRunner, moduleBlob: *IBlob) -> SlangResult { return this.vtable.loadModule(this, moduleBlob); }

IByteCodeRunner_selectFunctionByIndex :: inline (this: *IByteCodeRunner, functionIndex: u32) -> SlangResult { return this.vtable.selectFunctionByIndex(this, functionIndex); }

IByteCodeRunner_findFunctionByName :: inline (this: *IByteCodeRunner, name: *u8) -> s32 { return this.vtable.findFunctionByName(this, name); }

IByteCodeRunner_getFunctionInfo :: inline (this: *IByteCodeRunner, index: u32, outInfo: *ByteCodeFuncInfo) -> SlangResult { return this.vtable.getFunctionInfo(this, index, outInfo); }

IByteCodeRunner_getCurrentWorkingSet :: inline (this: *IByteCodeRunner) -> *void { return this.vtable.getCurrentWorkingSet(this); }

IByteCodeRunner_execute :: inline (this: *IByteCodeRunner, argumentData: *void, argumentSize: u64) -> SlangResult { return this.vtable.execute(this, argumentData, argumentSize); }

IByteCodeRunner_getErrorString :: inline (this: *IByteCodeRunner, outBlob: **IBlob) { this.vtable.getErrorString(this, outBlob); }

IByteCodeRunner_getReturnValue :: inline (this: *IByteCodeRunner, outValueSize: *u64) -> *void { return this.vtable.getReturnValue(this, outValueSize); }

IByteCodeRunner_setExtInstHandlerUserData :: inline (this: *IByteCodeRunner, userData: *void) { this.vtable.setExtInstHandlerUserData(this, userData); }

IByteCodeRunner_registerExtCall :: inline (this: *IByteCodeRunner, name: *u8, functionPtr: VMExtFunction) -> SlangResult { return this.vtable.registerExtCall(this, name, functionPtr); }

IByteCodeRunner_setPrintCallback :: inline (this: *IByteCodeRunner, callback: VMPrintFunc, userData: *void) -> SlangResult { return this.vtable.setPrintCallback(this, callback, userData); }

vtable :: (obj: *IByteCodeRunner) -> *IByteCodeRunner_VTable { return obj.vtable; }


/** A result code for a Slang API operation.

This type is generally compatible with the Windows API `HRESULT` type. In particular, negative
values indicate failure results, while zero or positive results indicate success.

In general, Slang APIs always return a zero result on success, unless documented otherwise.
Strictly speaking a negative value indicates an error, a positive (or 0) value indicates
success. This can be tested for with the macros SLANG_SUCCEEDED(x) or SLANG_FAILED(x).

It can represent if the call was successful or not. It can also specify in an extensible manner
what facility produced the result (as the integral 'facility') as well as what caused it (as an
integral 'code'). Under the covers SlangResult is represented as a int32_t.

SlangResult is designed to be compatible with COM HRESULT.

It's layout in bits is as follows

Severity | Facility | Code
---------|----------|-----
31       |    30-16 | 15-0

Severity - 1 fail, 0 is success - as SlangResult is signed 32 bits, means negative number
indicates failure. Facility is where the error originated from. Code is the code specific to the
facility.

Result codes have the following styles,
1) SLANG_name
2) SLANG_s_f_name
3) SLANG_s_name

where s is S for success, E for error
f is the short version of the facility name

Style 1 is reserved for SLANG_OK and SLANG_FAIL as they are so commonly used.

It is acceptable to expand 'f' to a longer name to differentiate a name or drop if unique
without it. ie for a facility 'DRIVER' it might make sense to have an error of the form
SLANG_E_DRIVER_OUT_OF_MEMORY
*/
SlangResult :: s32;

/** A "Universally Unique Identifier" (UUID)

The Slang API uses UUIDs to identify interfaces when
using `queryInterface`.

This type is compatible with the `GUID` type defined
by the Component Object Model (COM), but Slang is
not dependent on COM.
*/
SlangUUID :: struct {
    data1: u32;
    data2: u16;
    data3: u16;
    data4: [8] u8;
}

/** Base interface for components exchanged through the API.

This interface definition is compatible with the COM `IUnknown`,
and uses the same UUID, but Slang does not require applications
to use or initialize COM.
*/
ISlangUnknown :: struct {
    vtable: *ISlangUnknown_VTable;
}
ISlangUnknown_VTable :: struct #type_info_none {
    queryInterface: #type (this: *ISlangUnknown, uuid: *SlangUUID, outObject: **void) -> SlangResult #cpp_method;
    addRef:         #type (this: *ISlangUnknown) -> u32 #cpp_method;
    release:        #type (this: *ISlangUnknown) -> u32 #cpp_method;
}
ISlangUnknown_queryInterface :: inline (this: *ISlangUnknown, uuid: *SlangUUID, outObject: **void) -> SlangResult { return this.vtable.queryInterface(this, uuid, outObject); }
ISlangUnknown_addRef :: inline (this: *ISlangUnknown) -> u32 { return this.vtable.addRef(this); }
ISlangUnknown_release :: inline (this: *ISlangUnknown) -> u32 { return this.vtable.release(this); }

vtable :: (obj: *ISlangUnknown) -> *ISlangUnknown_VTable { return obj.vtable; }


/* An interface to provide a mechanism to cast, that doesn't require ref counting
and doesn't have to return a pointer to a ISlangUnknown derived class */
ISlangCastable :: struct {
    vtable: *ISlangCastable_VTable;
    #place vtable; #as islangunknown: ISlangUnknown; // Support cast to ISlangUnknown
}
ISlangCastable_VTable :: struct #type_info_none {
    using vtable: ISlangUnknown_VTable;
    castAs:       #type (this: *ISlangCastable, guid: *SlangUUID) -> *void #cpp_method;
}
ISlangCastable_castAs :: inline (this: *ISlangCastable, guid: *SlangUUID) -> *void { return this.vtable.castAs(this, guid); }

vtable :: (obj: *ISlangCastable) -> *ISlangCastable_VTable { return obj.vtable; }


ISlangClonable :: struct {
    vtable: *ISlangClonable_VTable;
    #place vtable; #as islangcastable: ISlangCastable; // Support cast to ISlangCastable
}
ISlangClonable_VTable :: struct #type_info_none {
    using,except(vtable) vtable: ISlangCastable_VTable;
    clone:  #type (this: *ISlangClonable, guid: *SlangUUID) -> *void #cpp_method;
}
ISlangClonable_clone :: inline (this: *ISlangClonable, guid: *SlangUUID) -> *void { return this.vtable.clone(this, guid); }

vtable :: (obj: *ISlangClonable) -> *ISlangClonable_VTable { return obj.vtable; }


/** A "blob" of binary data.

This interface definition is compatible with the `ID3DBlob` and `ID3D10Blob` interfaces.
*/
ISlangBlob :: struct {
    vtable: *ISlangBlob_VTable;
    #place vtable; #as islangunknown: ISlangUnknown; // Support cast to ISlangUnknown
}
ISlangBlob_VTable :: struct #type_info_none {
    using vtable:     ISlangUnknown_VTable;
    getBufferPointer: #type (this: *ISlangBlob) -> *void #cpp_method;
    getBufferSize:    #type (this: *ISlangBlob) -> u64 #cpp_method;
}
ISlangBlob_getBufferPointer :: inline (this: *ISlangBlob) -> *void { return this.vtable.getBufferPointer(this); }
ISlangBlob_getBufferSize :: inline (this: *ISlangBlob) -> u64 { return this.vtable.getBufferSize(this); }

vtable :: (obj: *ISlangBlob) -> *ISlangBlob_VTable { return obj.vtable; }


/* Can be requested from ISlangCastable cast to indicate the contained chars are null
* terminated.
*/
SlangTerminatedChars :: struct {
    chars: [1] u8;
}

/** A (real or virtual) file system.

Slang can make use of this interface whenever it would otherwise try to load files
from disk, allowing applications to hook and/or override filesystem access from
the compiler.

It is the responsibility of
the caller of any method that returns a ISlangBlob to release the blob when it is no
longer used (using 'release').
*/
ISlangFileSystem :: struct {
    vtable: *ISlangFileSystem_VTable;
    #place vtable; #as islangcastable: ISlangCastable; // Support cast to ISlangCastable
}
ISlangFileSystem_VTable :: struct #type_info_none {
    using,except(vtable) vtable:   ISlangCastable_VTable;
    loadFile: #type (this: *ISlangFileSystem, path: *u8, outBlob: **ISlangBlob) -> SlangResult #cpp_method;
}
ISlangFileSystem_loadFile :: inline (this: *ISlangFileSystem, path: *u8, outBlob: **ISlangBlob) -> SlangResult { return this.vtable.loadFile(this, path, outBlob); }

vtable :: (obj: *ISlangFileSystem) -> *ISlangFileSystem_VTable { return obj.vtable; }


SlangFuncPtr :: #type () -> void #c_call;

/**
(DEPRECATED) ISlangSharedLibrary
*/
ISlangSharedLibrary_Dep1 :: struct {
    vtable: *ISlangSharedLibrary_Dep1_VTable;
    #place vtable; #as islangunknown: ISlangUnknown; // Support cast to ISlangUnknown
}
ISlangSharedLibrary_Dep1_VTable :: struct #type_info_none {
    using vtable:            ISlangUnknown_VTable;
    findSymbolAddressByName: #type (this: *ISlangSharedLibrary_Dep1, name: *u8) -> *void #cpp_method;
}
ISlangSharedLibrary_Dep1_findSymbolAddressByName :: inline (this: *ISlangSharedLibrary_Dep1, name: *u8) -> *void { return this.vtable.findSymbolAddressByName(this, name); }

vtable :: (obj: *ISlangSharedLibrary_Dep1) -> *ISlangSharedLibrary_Dep1_VTable { return obj.vtable; }


/** An interface that can be used to encapsulate access to a shared library. An implementation
does not have to implement the library as a shared library
*/
ISlangSharedLibrary :: struct {
    vtable: *ISlangSharedLibrary_VTable;
    #place vtable; #as islangcastable: ISlangCastable; // Support cast to ISlangCastable
}
ISlangSharedLibrary_VTable :: struct #type_info_none {
    using,except(vtable) vtable:                  ISlangCastable_VTable;
    findSymbolAddressByName: #type (this: *ISlangSharedLibrary, name: *u8) -> *void #cpp_method;
}
ISlangSharedLibrary_findSymbolAddressByName :: inline (this: *ISlangSharedLibrary, name: *u8) -> *void { return this.vtable.findSymbolAddressByName(this, name); }

vtable :: (obj: *ISlangSharedLibrary) -> *ISlangSharedLibrary_VTable { return obj.vtable; }


ISlangSharedLibraryLoader :: struct {
    vtable: *ISlangSharedLibraryLoader_VTable;
    #place vtable; #as islangunknown: ISlangUnknown; // Support cast to ISlangUnknown
}
ISlangSharedLibraryLoader_VTable :: struct #type_info_none {
    using vtable:      ISlangUnknown_VTable;
    loadSharedLibrary: #type (this: *ISlangSharedLibraryLoader, path: *u8, sharedLibraryOut: **ISlangSharedLibrary) -> SlangResult #cpp_method;
}
ISlangSharedLibraryLoader_loadSharedLibrary :: inline (this: *ISlangSharedLibraryLoader, path: *u8, sharedLibraryOut: **ISlangSharedLibrary) -> SlangResult { return this.vtable.loadSharedLibrary(this, path, sharedLibraryOut); }

vtable :: (obj: *ISlangSharedLibraryLoader) -> *ISlangSharedLibraryLoader_VTable { return obj.vtable; }


/* Type that identifies how a path should be interpreted */
SlangPathTypeIntegral :: u32;
SlangPathType :: enum SlangPathTypeIntegral {
    DIRECTORY :: 0;
    FILE      :: 1;

    SLANG_PATH_TYPE_DIRECTORY :: DIRECTORY;
    SLANG_PATH_TYPE_FILE      :: FILE;
}

/* Callback to enumerate the contents of of a directory in a ISlangFileSystemExt.
The name is the name of a file system object (directory/file) in the specified path (ie it is
without a path) */
FileSystemContentsCallBack :: #type (pathType: SlangPathType, name: *u8, userData: *void) -> void #c_call;

/* Determines how paths map to files on the OS file system */
OSPathKind :: enum u8 {
    None            :: 0;
    Direct          :: 1;
    OperatingSystem :: 2;
}

/* Used to determine what kind of path is required from an input path */
PathKind :: enum s32 {
    Simplified      :: 0;

    Canonical       :: 1;

    Display         :: 2;

    OperatingSystem :: 3;

    CountOf         :: 4;
}

/** An extended file system abstraction.

Implementing and using this interface over ISlangFileSystem gives much more control over how
paths are managed, as well as how it is determined if two files 'are the same'.

All paths as input char*, or output as ISlangBlobs are always encoded as UTF-8 strings.
Blobs that contain strings are always zero terminated.
*/
ISlangFileSystemExt :: struct {
    vtable: *ISlangFileSystemExt_VTable;
    #place vtable; #as islangfilesystem: ISlangFileSystem; // Support cast to ISlangFileSystem
}
ISlangFileSystemExt_VTable :: struct #type_info_none {
    using,except(vtable) vtable:                ISlangFileSystem_VTable;
    getFileUniqueIdentity: #type (this: *ISlangFileSystemExt, path: *u8, outUniqueIdentity: **ISlangBlob) -> SlangResult #cpp_method;
    calcCombinedPath:      #type (this: *ISlangFileSystemExt, fromPathType: SlangPathType, fromPath: *u8, path: *u8, pathOut: **ISlangBlob) -> SlangResult #cpp_method;
    getPathType:           #type (this: *ISlangFileSystemExt, path: *u8, pathTypeOut: *SlangPathType) -> SlangResult #cpp_method;
    getPath:               #type (this: *ISlangFileSystemExt, kind: PathKind, path: *u8, outPath: **ISlangBlob) -> SlangResult #cpp_method;
    clearCache:            #type (this: *ISlangFileSystemExt) -> void #cpp_method;
    enumeratePathContents: #type (this: *ISlangFileSystemExt, path: *u8, callback: FileSystemContentsCallBack, userData: *void) -> SlangResult #cpp_method;
    getOSPathKind:         #type (this: *ISlangFileSystemExt) -> OSPathKind #cpp_method;
}
ISlangFileSystemExt_getFileUniqueIdentity :: inline (this: *ISlangFileSystemExt, path: *u8, outUniqueIdentity: **ISlangBlob) -> SlangResult { return this.vtable.getFileUniqueIdentity(this, path, outUniqueIdentity); }

ISlangFileSystemExt_calcCombinedPath :: inline (this: *ISlangFileSystemExt, fromPathType: SlangPathType, fromPath: *u8, path: *u8, pathOut: **ISlangBlob) -> SlangResult { return this.vtable.calcCombinedPath(this, fromPathType, fromPath, path, pathOut); }

ISlangFileSystemExt_getPathType :: inline (this: *ISlangFileSystemExt, path: *u8, pathTypeOut: *SlangPathType) -> SlangResult { return this.vtable.getPathType(this, path, pathTypeOut); }

ISlangFileSystemExt_getPath :: inline (this: *ISlangFileSystemExt, kind: PathKind, path: *u8, outPath: **ISlangBlob) -> SlangResult { return this.vtable.getPath(this, kind, path, outPath); }

ISlangFileSystemExt_clearCache :: inline (this: *ISlangFileSystemExt) { this.vtable.clearCache(this); }

ISlangFileSystemExt_enumeratePathContents :: inline (this: *ISlangFileSystemExt, path: *u8, callback: FileSystemContentsCallBack, userData: *void) -> SlangResult { return this.vtable.enumeratePathContents(this, path, callback, userData); }

ISlangFileSystemExt_getOSPathKind :: inline (this: *ISlangFileSystemExt) -> OSPathKind { return this.vtable.getOSPathKind(this); }

vtable :: (obj: *ISlangFileSystemExt) -> *ISlangFileSystemExt_VTable { return obj.vtable; }


ISlangMutableFileSystem :: struct {
    vtable: *ISlangMutableFileSystem_VTable;
    #place vtable; #as islangfilesystemext: ISlangFileSystemExt; // Support cast to ISlangFileSystemExt
}
ISlangMutableFileSystem_VTable :: struct #type_info_none {
    using,except(vtable) vtable:          ISlangFileSystemExt_VTable;
    saveFile:        #type (this: *ISlangMutableFileSystem, path: *u8, data: *void, size: u64) -> SlangResult #cpp_method;
    saveFileBlob:    #type (this: *ISlangMutableFileSystem, path: *u8, dataBlob: *ISlangBlob) -> SlangResult #cpp_method;
    _remove:         #type (this: *ISlangMutableFileSystem, path: *u8) -> SlangResult #cpp_method;
    createDirectory: #type (this: *ISlangMutableFileSystem, path: *u8) -> SlangResult #cpp_method;
}
ISlangMutableFileSystem_saveFile :: inline (this: *ISlangMutableFileSystem, path: *u8, data: *void, size: u64) -> SlangResult { return this.vtable.saveFile(this, path, data, size); }

ISlangMutableFileSystem_saveFileBlob :: inline (this: *ISlangMutableFileSystem, path: *u8, dataBlob: *ISlangBlob) -> SlangResult { return this.vtable.saveFileBlob(this, path, dataBlob); }

ISlangMutableFileSystem__remove :: inline (this: *ISlangMutableFileSystem, path: *u8) -> SlangResult { return this.vtable._remove(this, path); }

ISlangMutableFileSystem_createDirectory :: inline (this: *ISlangMutableFileSystem, path: *u8) -> SlangResult { return this.vtable.createDirectory(this, path); }

vtable :: (obj: *ISlangMutableFileSystem) -> *ISlangMutableFileSystem_VTable { return obj.vtable; }


/* Identifies different types of writer target*/
SlangWriterChannelIntegral :: u32;
SlangWriterChannel :: enum SlangWriterChannelIntegral {
    DIAGNOSTIC :: 0;
    STD_OUTPUT :: 1;
    STD_ERROR  :: 2;
    COUNT_OF   :: 3;

    SLANG_WRITER_CHANNEL_DIAGNOSTIC :: DIAGNOSTIC;
    SLANG_WRITER_CHANNEL_STD_OUTPUT :: STD_OUTPUT;
    SLANG_WRITER_CHANNEL_STD_ERROR  :: STD_ERROR;
    SLANG_WRITER_CHANNEL_COUNT_OF   :: COUNT_OF;
}

SlangWriterModeIntegral :: u32;
SlangWriterMode :: enum SlangWriterModeIntegral {
    TEXT   :: 0;
    BINARY :: 1;

    SLANG_WRITER_MODE_TEXT   :: TEXT;
    SLANG_WRITER_MODE_BINARY :: BINARY;
}

/** A stream typically of text, used for outputting diagnostic as well as other information.
*/
ISlangWriter :: struct {
    vtable: *ISlangWriter_VTable;
    #place vtable; #as islangunknown: ISlangUnknown; // Support cast to ISlangUnknown
}
ISlangWriter_VTable :: struct #type_info_none {
    using vtable:      ISlangUnknown_VTable;
    beginAppendBuffer: #type (this: *ISlangWriter, maxNumChars: u64) -> *u8 #cpp_method;
    endAppendBuffer:   #type (this: *ISlangWriter, buffer: *u8, numChars: u64) -> SlangResult #cpp_method;
    write:             #type (this: *ISlangWriter, chars: *u8, numChars: u64) -> SlangResult #cpp_method;
    flush:             #type (this: *ISlangWriter) -> void #cpp_method;
    isConsole:         #type (this: *ISlangWriter) -> SlangBool #cpp_method;
    setMode:           #type (this: *ISlangWriter, mode: SlangWriterMode) -> SlangResult #cpp_method;
}
ISlangWriter_beginAppendBuffer :: inline (this: *ISlangWriter, maxNumChars: u64) -> *u8 { return this.vtable.beginAppendBuffer(this, maxNumChars); }

ISlangWriter_endAppendBuffer :: inline (this: *ISlangWriter, buffer: *u8, numChars: u64) -> SlangResult { return this.vtable.endAppendBuffer(this, buffer, numChars); }

ISlangWriter_write :: inline (this: *ISlangWriter, chars: *u8, numChars: u64) -> SlangResult { return this.vtable.write(this, chars, numChars); }

ISlangWriter_flush :: inline (this: *ISlangWriter) { this.vtable.flush(this); }

ISlangWriter_isConsole :: inline (this: *ISlangWriter) -> SlangBool { return this.vtable.isConsole(this); }

ISlangWriter_setMode :: inline (this: *ISlangWriter, mode: SlangWriterMode) -> SlangResult { return this.vtable.setMode(this, mode); }

vtable :: (obj: *ISlangWriter) -> *ISlangWriter_VTable { return obj.vtable; }


ISlangProfiler :: struct {
    vtable: *ISlangProfiler_VTable;
    #place vtable; #as islangunknown: ISlangUnknown; // Support cast to ISlangUnknown
}
ISlangProfiler_VTable :: struct #type_info_none {
    using vtable:            ISlangUnknown_VTable;
    getEntryCount:           #type (this: *ISlangProfiler) -> u64 #cpp_method;
    getEntryName:            #type (this: *ISlangProfiler, index: u32) -> *u8 #cpp_method;
    getEntryTimeMS:          #type (this: *ISlangProfiler, index: u32) -> s32 #cpp_method;
    getEntryInvocationTimes: #type (this: *ISlangProfiler, index: u32) -> u32 #cpp_method;
}
ISlangProfiler_getEntryCount :: inline (this: *ISlangProfiler) -> u64 { return this.vtable.getEntryCount(this); }
ISlangProfiler_getEntryName :: inline (this: *ISlangProfiler, index: u32) -> *u8 { return this.vtable.getEntryName(this, index); }
ISlangProfiler_getEntryTimeMS :: inline (this: *ISlangProfiler, index: u32) -> s32 { return this.vtable.getEntryTimeMS(this, index); }
ISlangProfiler_getEntryInvocationTimes :: inline (this: *ISlangProfiler, index: u32) -> u32 { return this.vtable.getEntryInvocationTimes(this, index); }

vtable :: (obj: *ISlangProfiler) -> *ISlangProfiler_VTable { return obj.vtable; }


/*!
@brief An instance of the Slang library.
*/
SlangSession :: IGlobalSession;

SlangProgramLayout :: struct {}

/*!
@brief A request for one or more compilation actions to be performed.
*/
SlangCompileRequest :: ICompileRequest;

/*!
@brief Callback type used for diagnostic output.
*/
SlangDiagnosticCallback :: #type (message: *u8, userData: *void) -> void #c_call;

/*!
@brief Get the build version 'tag' string. The string is the same as
produced via `git describe --tags --match v*` for the project. If such a
version could not be determined at build time then the contents will be
0.0.0-unknown. Any string can be set by passing
-DSLANG_VERSION_FULL=whatever during the cmake invocation.

This function will return exactly the same result as the method
getBuildTagString on IGlobalSession.

An advantage of using this function over the method is that doing so does
not require the creation of a session, which can be a fairly costly
operation.

@return The build tag string
*/
spGetBuildTagString :: () -> *u8 #foreign slang;

SlangEntryPoint :: struct {}
SlangEntryPointLayout :: struct {}

SlangReflectionDecl :: struct {}
SlangReflectionModifier :: struct {}
SlangReflectionType :: struct {}
SlangReflectionTypeLayout :: struct {}
SlangReflectionVariable :: struct {}
SlangReflectionVariableLayout :: struct {}
SlangReflectionTypeParameter :: struct {}
SlangReflectionUserAttribute :: struct {}
SlangReflectionAttribute :: SlangReflectionUserAttribute;
SlangReflectionFunction :: struct {}
SlangReflectionGeneric :: struct {}

SlangReflectionGenericArg :: union {
    typeVal: *SlangReflectionType;
    intVal:  s64;
    boolVal: bool;
}

SlangReflectionGenericArgType :: enum s32 {
    TYPE :: 0;
    INT  :: 1;
    BOOL :: 2;

    SLANG_GENERIC_ARG_TYPE :: TYPE;
    SLANG_GENERIC_ARG_INT  :: INT;
    SLANG_GENERIC_ARG_BOOL :: BOOL;
}

/*
Type aliases to maintain backward compatibility.
*/
SlangReflection :: SlangProgramLayout;
SlangReflectionEntryPoint :: SlangEntryPointLayout;

// type reflection
SlangTypeKindIntegral :: u32;
SlangTypeKind :: enum SlangTypeKindIntegral {
    NONE                   :: 0;
    STRUCT                 :: 1;
    ARRAY                  :: 2;
    MATRIX                 :: 3;
    VECTOR                 :: 4;
    SCALAR                 :: 5;
    CONSTANT_BUFFER        :: 6;
    RESOURCE               :: 7;
    SAMPLER_STATE          :: 8;
    TEXTURE_BUFFER         :: 9;
    SHADER_STORAGE_BUFFER  :: 10;
    PARAMETER_BLOCK        :: 11;
    GENERIC_TYPE_PARAMETER :: 12;
    INTERFACE              :: 13;
    OUTPUT_STREAM          :: 14;
    MESH_OUTPUT            :: 15;
    SPECIALIZED            :: 16;
    FEEDBACK               :: 17;
    POINTER                :: 18;
    DYNAMIC_RESOURCE       :: 19;
    COUNT                  :: 20;

    SLANG_TYPE_KIND_NONE                   :: NONE;
    SLANG_TYPE_KIND_STRUCT                 :: STRUCT;
    SLANG_TYPE_KIND_ARRAY                  :: ARRAY;
    SLANG_TYPE_KIND_MATRIX                 :: MATRIX;
    SLANG_TYPE_KIND_VECTOR                 :: VECTOR;
    SLANG_TYPE_KIND_SCALAR                 :: SCALAR;
    SLANG_TYPE_KIND_CONSTANT_BUFFER        :: CONSTANT_BUFFER;
    SLANG_TYPE_KIND_RESOURCE               :: RESOURCE;
    SLANG_TYPE_KIND_SAMPLER_STATE          :: SAMPLER_STATE;
    SLANG_TYPE_KIND_TEXTURE_BUFFER         :: TEXTURE_BUFFER;
    SLANG_TYPE_KIND_SHADER_STORAGE_BUFFER  :: SHADER_STORAGE_BUFFER;
    SLANG_TYPE_KIND_PARAMETER_BLOCK        :: PARAMETER_BLOCK;
    SLANG_TYPE_KIND_GENERIC_TYPE_PARAMETER :: GENERIC_TYPE_PARAMETER;
    SLANG_TYPE_KIND_INTERFACE              :: INTERFACE;
    SLANG_TYPE_KIND_OUTPUT_STREAM          :: OUTPUT_STREAM;
    SLANG_TYPE_KIND_MESH_OUTPUT            :: MESH_OUTPUT;
    SLANG_TYPE_KIND_SPECIALIZED            :: SPECIALIZED;
    SLANG_TYPE_KIND_FEEDBACK               :: FEEDBACK;
    SLANG_TYPE_KIND_POINTER                :: POINTER;
    SLANG_TYPE_KIND_DYNAMIC_RESOURCE       :: DYNAMIC_RESOURCE;
    SLANG_TYPE_KIND_COUNT                  :: COUNT;
}

SlangScalarTypeIntegral :: u32;
SlangScalarType :: enum SlangScalarTypeIntegral {
    NONE    :: 0;
    VOID    :: 1;
    BOOL    :: 2;
    INT32   :: 3;
    UINT32  :: 4;
    INT64   :: 5;
    UINT64  :: 6;
    FLOAT16 :: 7;
    FLOAT32 :: 8;
    FLOAT64 :: 9;
    INT8    :: 10;
    UINT8   :: 11;
    INT16   :: 12;
    UINT16  :: 13;
    INTPTR  :: 14;
    UINTPTR :: 15;

    SLANG_SCALAR_TYPE_NONE    :: NONE;
    SLANG_SCALAR_TYPE_VOID    :: VOID;
    SLANG_SCALAR_TYPE_BOOL    :: BOOL;
    SLANG_SCALAR_TYPE_INT32   :: INT32;
    SLANG_SCALAR_TYPE_UINT32  :: UINT32;
    SLANG_SCALAR_TYPE_INT64   :: INT64;
    SLANG_SCALAR_TYPE_UINT64  :: UINT64;
    SLANG_SCALAR_TYPE_FLOAT16 :: FLOAT16;
    SLANG_SCALAR_TYPE_FLOAT32 :: FLOAT32;
    SLANG_SCALAR_TYPE_FLOAT64 :: FLOAT64;
    SLANG_SCALAR_TYPE_INT8    :: INT8;
    SLANG_SCALAR_TYPE_UINT8   :: UINT8;
    SLANG_SCALAR_TYPE_INT16   :: INT16;
    SLANG_SCALAR_TYPE_UINT16  :: UINT16;
    SLANG_SCALAR_TYPE_INTPTR  :: INTPTR;
    SLANG_SCALAR_TYPE_UINTPTR :: UINTPTR;
}

// abstract decl reflection
SlangDeclKindIntegral :: u32;
SlangDeclKind :: enum SlangDeclKindIntegral {
    UNSUPPORTED_FOR_REFLECTION :: 0;
    STRUCT                     :: 1;
    FUNC                       :: 2;
    MODULE                     :: 3;
    GENERIC                    :: 4;
    VARIABLE                   :: 5;
    NAMESPACE                  :: 6;

    SLANG_DECL_KIND_UNSUPPORTED_FOR_REFLECTION :: UNSUPPORTED_FOR_REFLECTION;
    SLANG_DECL_KIND_STRUCT                     :: STRUCT;
    SLANG_DECL_KIND_FUNC                       :: FUNC;
    SLANG_DECL_KIND_MODULE                     :: MODULE;
    SLANG_DECL_KIND_GENERIC                    :: GENERIC;
    SLANG_DECL_KIND_VARIABLE                   :: VARIABLE;
    SLANG_DECL_KIND_NAMESPACE                  :: NAMESPACE;
}

SlangResourceShapeIntegral :: u32;
SlangResourceShape :: enum SlangResourceShapeIntegral {
    RESOURCE_BASE_SHAPE_MASK     :: 15;

    RESOURCE_NONE                :: 0;

    TEXTURE_1D                   :: 1;
    TEXTURE_2D                   :: 2;
    TEXTURE_3D                   :: 3;
    TEXTURE_CUBE                 :: 4;
    TEXTURE_BUFFER               :: 5;

    STRUCTURED_BUFFER            :: 6;
    BYTE_ADDRESS_BUFFER          :: 7;
    RESOURCE_UNKNOWN             :: 8;
    ACCELERATION_STRUCTURE       :: 9;
    TEXTURE_SUBPASS              :: 10;

    RESOURCE_EXT_SHAPE_MASK      :: 496;

    TEXTURE_FEEDBACK_FLAG        :: 16;
    TEXTURE_SHADOW_FLAG          :: 32;
    TEXTURE_ARRAY_FLAG           :: 64;
    TEXTURE_MULTISAMPLE_FLAG     :: 128;
    TEXTURE_COMBINED_FLAG        :: 256;

    TEXTURE_1D_ARRAY             :: 65;
    TEXTURE_2D_ARRAY             :: 66;
    TEXTURE_CUBE_ARRAY           :: 68;

    TEXTURE_2D_MULTISAMPLE       :: 130;
    TEXTURE_2D_MULTISAMPLE_ARRAY :: 194;

    TEXTURE_SUBPASS_MULTISAMPLE  :: 138;

    SLANG_RESOURCE_BASE_SHAPE_MASK     :: RESOURCE_BASE_SHAPE_MASK;

    SLANG_RESOURCE_NONE                :: RESOURCE_NONE;

    SLANG_TEXTURE_1D                   :: TEXTURE_1D;
    SLANG_TEXTURE_2D                   :: TEXTURE_2D;
    SLANG_TEXTURE_3D                   :: TEXTURE_3D;
    SLANG_TEXTURE_CUBE                 :: TEXTURE_CUBE;
    SLANG_TEXTURE_BUFFER               :: TEXTURE_BUFFER;

    SLANG_STRUCTURED_BUFFER            :: STRUCTURED_BUFFER;
    SLANG_BYTE_ADDRESS_BUFFER          :: BYTE_ADDRESS_BUFFER;
    SLANG_RESOURCE_UNKNOWN             :: RESOURCE_UNKNOWN;
    SLANG_ACCELERATION_STRUCTURE       :: ACCELERATION_STRUCTURE;
    SLANG_TEXTURE_SUBPASS              :: TEXTURE_SUBPASS;

    SLANG_RESOURCE_EXT_SHAPE_MASK      :: RESOURCE_EXT_SHAPE_MASK;

    SLANG_TEXTURE_FEEDBACK_FLAG        :: TEXTURE_FEEDBACK_FLAG;
    SLANG_TEXTURE_SHADOW_FLAG          :: TEXTURE_SHADOW_FLAG;
    SLANG_TEXTURE_ARRAY_FLAG           :: TEXTURE_ARRAY_FLAG;
    SLANG_TEXTURE_MULTISAMPLE_FLAG     :: TEXTURE_MULTISAMPLE_FLAG;
    SLANG_TEXTURE_COMBINED_FLAG        :: TEXTURE_COMBINED_FLAG;

    SLANG_TEXTURE_1D_ARRAY             :: TEXTURE_1D_ARRAY;
    SLANG_TEXTURE_2D_ARRAY             :: TEXTURE_2D_ARRAY;
    SLANG_TEXTURE_CUBE_ARRAY           :: TEXTURE_CUBE_ARRAY;

    SLANG_TEXTURE_2D_MULTISAMPLE       :: TEXTURE_2D_MULTISAMPLE;
    SLANG_TEXTURE_2D_MULTISAMPLE_ARRAY :: TEXTURE_2D_MULTISAMPLE_ARRAY;

    SLANG_TEXTURE_SUBPASS_MULTISAMPLE  :: TEXTURE_SUBPASS_MULTISAMPLE;
}

SlangResourceAccessIntegral :: u32;
SlangResourceAccess :: enum SlangResourceAccessIntegral {
    NONE           :: 0;
    READ           :: 1;
    READ_WRITE     :: 2;
    RASTER_ORDERED :: 3;
    APPEND         :: 4;
    CONSUME        :: 5;
    WRITE          :: 6;
    FEEDBACK       :: 7;
    UNKNOWN        :: 2147483647;

    SLANG_RESOURCE_ACCESS_NONE           :: NONE;
    SLANG_RESOURCE_ACCESS_READ           :: READ;
    SLANG_RESOURCE_ACCESS_READ_WRITE     :: READ_WRITE;
    SLANG_RESOURCE_ACCESS_RASTER_ORDERED :: RASTER_ORDERED;
    SLANG_RESOURCE_ACCESS_APPEND         :: APPEND;
    SLANG_RESOURCE_ACCESS_CONSUME        :: CONSUME;
    SLANG_RESOURCE_ACCESS_WRITE          :: WRITE;
    SLANG_RESOURCE_ACCESS_FEEDBACK       :: FEEDBACK;
    SLANG_RESOURCE_ACCESS_UNKNOWN        :: UNKNOWN;
}

SlangParameterCategoryIntegral :: u32;
SlangParameterCategory :: enum SlangParameterCategoryIntegral {
    NONE                          :: 0;
    MIXED                         :: 1;
    CONSTANT_BUFFER               :: 2;
    SHADER_RESOURCE               :: 3;
    UNORDERED_ACCESS              :: 4;
    VARYING_INPUT                 :: 5;
    VARYING_OUTPUT                :: 6;
    SAMPLER_STATE                 :: 7;
    UNIFORM                       :: 8;
    DESCRIPTOR_TABLE_SLOT         :: 9;
    SPECIALIZATION_CONSTANT       :: 10;
    PUSH_CONSTANT_BUFFER          :: 11;

    REGISTER_SPACE                :: 12;

    GENERIC                       :: 13;

    RAY_PAYLOAD                   :: 14;
    HIT_ATTRIBUTES                :: 15;
    CALLABLE_PAYLOAD              :: 16;
    SHADER_RECORD                 :: 17;

    EXISTENTIAL_TYPE_PARAM        :: 18;

    EXISTENTIAL_OBJECT_PARAM      :: 19;

    SUB_ELEMENT_REGISTER_SPACE    :: 20;

    SUBPASS                       :: 21;

    METAL_ARGUMENT_BUFFER_ELEMENT :: 22;

    METAL_ATTRIBUTE               :: 23;

    METAL_PAYLOAD                 :: 24;

    COUNT                         :: 25;

    METAL_BUFFER                  :: 2;
    METAL_TEXTURE                 :: 3;
    METAL_SAMPLER                 :: 7;

    VERTEX_INPUT                  :: 5;
    FRAGMENT_OUTPUT               :: 6;
    COUNT_V1                      :: 21;

    SLANG_PARAMETER_CATEGORY_NONE                          :: NONE;
    SLANG_PARAMETER_CATEGORY_MIXED                         :: MIXED;
    SLANG_PARAMETER_CATEGORY_CONSTANT_BUFFER               :: CONSTANT_BUFFER;
    SLANG_PARAMETER_CATEGORY_SHADER_RESOURCE               :: SHADER_RESOURCE;
    SLANG_PARAMETER_CATEGORY_UNORDERED_ACCESS              :: UNORDERED_ACCESS;
    SLANG_PARAMETER_CATEGORY_VARYING_INPUT                 :: VARYING_INPUT;
    SLANG_PARAMETER_CATEGORY_VARYING_OUTPUT                :: VARYING_OUTPUT;
    SLANG_PARAMETER_CATEGORY_SAMPLER_STATE                 :: SAMPLER_STATE;
    SLANG_PARAMETER_CATEGORY_UNIFORM                       :: UNIFORM;
    SLANG_PARAMETER_CATEGORY_DESCRIPTOR_TABLE_SLOT         :: DESCRIPTOR_TABLE_SLOT;
    SLANG_PARAMETER_CATEGORY_SPECIALIZATION_CONSTANT       :: SPECIALIZATION_CONSTANT;
    SLANG_PARAMETER_CATEGORY_PUSH_CONSTANT_BUFFER          :: PUSH_CONSTANT_BUFFER;

    SLANG_PARAMETER_CATEGORY_REGISTER_SPACE                :: REGISTER_SPACE;

    SLANG_PARAMETER_CATEGORY_GENERIC                       :: GENERIC;

    SLANG_PARAMETER_CATEGORY_RAY_PAYLOAD                   :: RAY_PAYLOAD;
    SLANG_PARAMETER_CATEGORY_HIT_ATTRIBUTES                :: HIT_ATTRIBUTES;
    SLANG_PARAMETER_CATEGORY_CALLABLE_PAYLOAD              :: CALLABLE_PAYLOAD;
    SLANG_PARAMETER_CATEGORY_SHADER_RECORD                 :: SHADER_RECORD;

    SLANG_PARAMETER_CATEGORY_EXISTENTIAL_TYPE_PARAM        :: EXISTENTIAL_TYPE_PARAM;

    SLANG_PARAMETER_CATEGORY_EXISTENTIAL_OBJECT_PARAM      :: EXISTENTIAL_OBJECT_PARAM;

    SLANG_PARAMETER_CATEGORY_SUB_ELEMENT_REGISTER_SPACE    :: SUB_ELEMENT_REGISTER_SPACE;

    SLANG_PARAMETER_CATEGORY_SUBPASS                       :: SUBPASS;

    SLANG_PARAMETER_CATEGORY_METAL_ARGUMENT_BUFFER_ELEMENT :: METAL_ARGUMENT_BUFFER_ELEMENT;

    SLANG_PARAMETER_CATEGORY_METAL_ATTRIBUTE               :: METAL_ATTRIBUTE;

    SLANG_PARAMETER_CATEGORY_METAL_PAYLOAD                 :: METAL_PAYLOAD;

    SLANG_PARAMETER_CATEGORY_COUNT                         :: COUNT;

    SLANG_PARAMETER_CATEGORY_METAL_BUFFER                  :: METAL_BUFFER;
    SLANG_PARAMETER_CATEGORY_METAL_TEXTURE                 :: METAL_TEXTURE;
    SLANG_PARAMETER_CATEGORY_METAL_SAMPLER                 :: METAL_SAMPLER;

    SLANG_PARAMETER_CATEGORY_VERTEX_INPUT                  :: VERTEX_INPUT;
    SLANG_PARAMETER_CATEGORY_FRAGMENT_OUTPUT               :: FRAGMENT_OUTPUT;
    SLANG_PARAMETER_CATEGORY_COUNT_V1                      :: COUNT_V1;
}

/** Types of API-managed bindings that a parameter might use.

`SlangBindingType` represents the distinct types of binding ranges that might be
understood by an underlying graphics API or cross-API abstraction layer.
Several of the enumeration cases here correspond to cases of `VkDescriptorType`
defined by the Vulkan API. Note however that the values of this enumeration
are not the same as those of any particular API.

The `SlangBindingType` enumeration is distinct from `SlangParameterCategory`
because `SlangParameterCategory` differentiates the types of parameters for
the purposes of layout, where the layout rules of some targets will treat
parameters of different types as occupying the same binding space for layout
(e.g., in SPIR-V both a `Texture2D` and `SamplerState` use the same space of
`binding` indices, and are not allowed to overlap), while those same types
map to different types of bindings in the API (e.g., both textures and samplers
use different `VkDescriptorType` values).

When you want to answer "what register/binding did this parameter use?" you
should use `SlangParameterCategory`.

When you want to answer "what type of descriptor range should this parameter use?"
you should use `SlangBindingType`.
*/
SlangBindingTypeIntegral :: SlangUInt32;
SlangBindingType :: enum SlangBindingTypeIntegral {
    UNKNOWN                            :: 0;

    SAMPLER                            :: 1;
    TEXTURE                            :: 2;
    CONSTANT_BUFFER                    :: 3;
    PARAMETER_BLOCK                    :: 4;
    TYPED_BUFFER                       :: 5;
    RAW_BUFFER                         :: 6;
    COMBINED_TEXTURE_SAMPLER           :: 7;
    INPUT_RENDER_TARGET                :: 8;
    INLINE_UNIFORM_DATA                :: 9;
    RAY_TRACING_ACCELERATION_STRUCTURE :: 10;

    VARYING_INPUT                      :: 11;
    VARYING_OUTPUT                     :: 12;

    EXISTENTIAL_VALUE                  :: 13;
    PUSH_CONSTANT                      :: 14;

    MUTABLE_FLAG                       :: 256;

    MUTABLE_TETURE                     :: 258;

    MUTABLE_TYPED_BUFFER               :: 261;

    MUTABLE_RAW_BUFFER                 :: 262;

    BASE_MASK                          :: 255;
    EXT_MASK                           :: 65280;

    SLANG_BINDING_TYPE_UNKNOWN                            :: UNKNOWN;

    SLANG_BINDING_TYPE_SAMPLER                            :: SAMPLER;
    SLANG_BINDING_TYPE_TEXTURE                            :: TEXTURE;
    SLANG_BINDING_TYPE_CONSTANT_BUFFER                    :: CONSTANT_BUFFER;
    SLANG_BINDING_TYPE_PARAMETER_BLOCK                    :: PARAMETER_BLOCK;
    SLANG_BINDING_TYPE_TYPED_BUFFER                       :: TYPED_BUFFER;
    SLANG_BINDING_TYPE_RAW_BUFFER                         :: RAW_BUFFER;
    SLANG_BINDING_TYPE_COMBINED_TEXTURE_SAMPLER           :: COMBINED_TEXTURE_SAMPLER;
    SLANG_BINDING_TYPE_INPUT_RENDER_TARGET                :: INPUT_RENDER_TARGET;
    SLANG_BINDING_TYPE_INLINE_UNIFORM_DATA                :: INLINE_UNIFORM_DATA;
    SLANG_BINDING_TYPE_RAY_TRACING_ACCELERATION_STRUCTURE :: RAY_TRACING_ACCELERATION_STRUCTURE;

    SLANG_BINDING_TYPE_VARYING_INPUT                      :: VARYING_INPUT;
    SLANG_BINDING_TYPE_VARYING_OUTPUT                     :: VARYING_OUTPUT;

    SLANG_BINDING_TYPE_EXISTENTIAL_VALUE                  :: EXISTENTIAL_VALUE;
    SLANG_BINDING_TYPE_PUSH_CONSTANT                      :: PUSH_CONSTANT;

    SLANG_BINDING_TYPE_MUTABLE_FLAG                       :: MUTABLE_FLAG;

    SLANG_BINDING_TYPE_MUTABLE_TETURE                     :: MUTABLE_TETURE;

    SLANG_BINDING_TYPE_MUTABLE_TYPED_BUFFER               :: MUTABLE_TYPED_BUFFER;

    SLANG_BINDING_TYPE_MUTABLE_RAW_BUFFER                 :: MUTABLE_RAW_BUFFER;

    SLANG_BINDING_TYPE_BASE_MASK                          :: BASE_MASK;
    SLANG_BINDING_TYPE_EXT_MASK                           :: EXT_MASK;
}

SlangLayoutRulesIntegral :: SlangUInt32;
SlangLayoutRules :: enum SlangLayoutRulesIntegral {
    DEFAULT                      :: 0;
    METAL_ARGUMENT_BUFFER_TIER_2 :: 1;

    SLANG_LAYOUT_RULES_DEFAULT                      :: DEFAULT;
    SLANG_LAYOUT_RULES_METAL_ARGUMENT_BUFFER_TIER_2 :: METAL_ARGUMENT_BUFFER_TIER_2;
}

SlangModifierIDIntegral :: SlangUInt32;
SlangModifierID :: enum SlangModifierIDIntegral {
    SHARED         :: 0;
    NO_DIFF        :: 1;
    STATIC         :: 2;
    CONST          :: 3;
    EXPORT         :: 4;
    EXTERN         :: 5;
    DIFFERENTIABLE :: 6;
    MUTATING       :: 7;
    IN             :: 8;
    OUT            :: 9;
    INOUT          :: 10;

    SLANG_MODIFIER_SHARED         :: SHARED;
    SLANG_MODIFIER_NO_DIFF        :: NO_DIFF;
    SLANG_MODIFIER_STATIC         :: STATIC;
    SLANG_MODIFIER_CONST          :: CONST;
    SLANG_MODIFIER_EXPORT         :: EXPORT;
    SLANG_MODIFIER_EXTERN         :: EXTERN;
    SLANG_MODIFIER_DIFFERENTIABLE :: DIFFERENTIABLE;
    SLANG_MODIFIER_MUTATING       :: MUTATING;
    SLANG_MODIFIER_IN             :: IN;
    SLANG_MODIFIER_OUT            :: OUT;
    SLANG_MODIFIER_INOUT          :: INOUT;
}

SlangImageFormatIntegral :: SlangUInt32;
SlangImageFormat :: enum SlangImageFormatIntegral {
    unknown        :: 0;
    rgba32f        :: 1;
    rgba16f        :: 2;
    rg32f          :: 3;
    rg16f          :: 4;
    r11f_g11f_b10f :: 5;
    r32f           :: 6;
    r16f           :: 7;
    rgba16         :: 8;
    rgb10_a2       :: 9;
    rgba8          :: 10;
    rg16           :: 11;
    rg8            :: 12;
    r16            :: 13;
    r8             :: 14;
    rgba16_snorm   :: 15;
    rgba8_snorm    :: 16;
    rg16_snorm     :: 17;
    rg8_snorm      :: 18;
    r16_snorm      :: 19;
    r8_snorm       :: 20;
    rgba32i        :: 21;
    rgba16i        :: 22;
    rgba8i         :: 23;
    rg32i          :: 24;
    rg16i          :: 25;
    rg8i           :: 26;
    r32i           :: 27;
    r16i           :: 28;
    r8i            :: 29;
    rgba32ui       :: 30;
    rgba16ui       :: 31;
    rgb10_a2ui     :: 32;
    rgba8ui        :: 33;
    rg32ui         :: 34;
    rg16ui         :: 35;
    rg8ui          :: 36;
    r32ui          :: 37;
    r16ui          :: 38;
    r8ui           :: 39;
    r64ui          :: 40;
    r64i           :: 41;
    bgra8          :: 42;

    SLANG_IMAGE_FORMAT_unknown        :: unknown;
    SLANG_IMAGE_FORMAT_rgba32f        :: rgba32f;
    SLANG_IMAGE_FORMAT_rgba16f        :: rgba16f;
    SLANG_IMAGE_FORMAT_rg32f          :: rg32f;
    SLANG_IMAGE_FORMAT_rg16f          :: rg16f;
    SLANG_IMAGE_FORMAT_r11f_g11f_b10f :: r11f_g11f_b10f;
    SLANG_IMAGE_FORMAT_r32f           :: r32f;
    SLANG_IMAGE_FORMAT_r16f           :: r16f;
    SLANG_IMAGE_FORMAT_rgba16         :: rgba16;
    SLANG_IMAGE_FORMAT_rgb10_a2       :: rgb10_a2;
    SLANG_IMAGE_FORMAT_rgba8          :: rgba8;
    SLANG_IMAGE_FORMAT_rg16           :: rg16;
    SLANG_IMAGE_FORMAT_rg8            :: rg8;
    SLANG_IMAGE_FORMAT_r16            :: r16;
    SLANG_IMAGE_FORMAT_r8             :: r8;
    SLANG_IMAGE_FORMAT_rgba16_snorm   :: rgba16_snorm;
    SLANG_IMAGE_FORMAT_rgba8_snorm    :: rgba8_snorm;
    SLANG_IMAGE_FORMAT_rg16_snorm     :: rg16_snorm;
    SLANG_IMAGE_FORMAT_rg8_snorm      :: rg8_snorm;
    SLANG_IMAGE_FORMAT_r16_snorm      :: r16_snorm;
    SLANG_IMAGE_FORMAT_r8_snorm       :: r8_snorm;
    SLANG_IMAGE_FORMAT_rgba32i        :: rgba32i;
    SLANG_IMAGE_FORMAT_rgba16i        :: rgba16i;
    SLANG_IMAGE_FORMAT_rgba8i         :: rgba8i;
    SLANG_IMAGE_FORMAT_rg32i          :: rg32i;
    SLANG_IMAGE_FORMAT_rg16i          :: rg16i;
    SLANG_IMAGE_FORMAT_rg8i           :: rg8i;
    SLANG_IMAGE_FORMAT_r32i           :: r32i;
    SLANG_IMAGE_FORMAT_r16i           :: r16i;
    SLANG_IMAGE_FORMAT_r8i            :: r8i;
    SLANG_IMAGE_FORMAT_rgba32ui       :: rgba32ui;
    SLANG_IMAGE_FORMAT_rgba16ui       :: rgba16ui;
    SLANG_IMAGE_FORMAT_rgb10_a2ui     :: rgb10_a2ui;
    SLANG_IMAGE_FORMAT_rgba8ui        :: rgba8ui;
    SLANG_IMAGE_FORMAT_rg32ui         :: rg32ui;
    SLANG_IMAGE_FORMAT_rg16ui         :: rg16ui;
    SLANG_IMAGE_FORMAT_rg8ui          :: rg8ui;
    SLANG_IMAGE_FORMAT_r32ui          :: r32ui;
    SLANG_IMAGE_FORMAT_r16ui          :: r16ui;
    SLANG_IMAGE_FORMAT_r8ui           :: r8ui;
    SLANG_IMAGE_FORMAT_r64ui          :: r64ui;
    SLANG_IMAGE_FORMAT_r64i           :: r64i;
    SLANG_IMAGE_FORMAT_bgra8          :: bgra8;
}

// Shader Parameter Reflection
SlangReflectionParameter :: SlangReflectionVariableLayout;

/*!
@brief Initialize an instance of the Slang library.
*/
spCreateSession :: (deprecated: *u8 = null) -> *SlangSession #foreign slang;

/*!
@brief Clean up after an instance of the Slang library.
*/
spDestroySession :: (session: *SlangSession) -> void #foreign slang;

/** @see slang::IGlobalSession::setSharedLibraryLoader
*/
spSessionSetSharedLibraryLoader :: (session: *SlangSession, loader: *ISlangSharedLibraryLoader) -> void #foreign slang;

/** @see slang::IGlobalSession::getSharedLibraryLoader
*/
spSessionGetSharedLibraryLoader :: (session: *SlangSession) -> *ISlangSharedLibraryLoader #foreign slang;

/** @see slang::IGlobalSession::checkCompileTargetSupport
*/
spSessionCheckCompileTargetSupport :: (session: *SlangSession, target: SlangCompileTarget) -> SlangResult #foreign slang;

/** @see slang::IGlobalSession::checkPassThroughSupport
*/
spSessionCheckPassThroughSupport :: (session: *SlangSession, passThrough: SlangPassThrough) -> SlangResult #foreign slang;

/** @see slang::IGlobalSession::addBuiltins
*/
spAddBuiltins :: (session: *SlangSession, sourcePath: *u8, sourceString: *u8) -> void #foreign slang;

/* @see slang::IGlobalSession::createCompileRequest
*/
spCreateCompileRequest :: (session: *SlangSession) -> *SlangCompileRequest #foreign slang;

/*!
@brief Destroy a compile request.
Note a request is a COM object and can be destroyed via 'Release'.
*/
spDestroyCompileRequest :: (request: *SlangCompileRequest) -> void #foreign slang;

/*! @see slang::ICompileRequest::setFileSystem */
spSetFileSystem :: (request: *SlangCompileRequest, fileSystem: *ISlangFileSystem) -> void #foreign slang;

/*! @see slang::ICompileRequest::setCompileFlags */
spSetCompileFlags :: (request: *SlangCompileRequest, flags: SlangCompileFlags) -> void #foreign slang;

/*! @see slang::ICompileRequest::getCompileFlags */
spGetCompileFlags :: (request: *SlangCompileRequest) -> SlangCompileFlags #foreign slang;

/*! @see slang::ICompileRequest::setDumpIntermediates */
spSetDumpIntermediates :: (request: *SlangCompileRequest, enable: s32) -> void #foreign slang;

/*! @see slang::ICompileRequest::setDumpIntermediatePrefix */
spSetDumpIntermediatePrefix :: (request: *SlangCompileRequest, prefix: *u8) -> void #foreign slang;

/*! DEPRECATED: use `spSetTargetLineDirectiveMode` instead.
@see slang::ICompileRequest::setLineDirectiveMode */
spSetLineDirectiveMode :: (request: *SlangCompileRequest, mode: SlangLineDirectiveMode) -> void #foreign slang;

/*! @see slang::ICompileRequest::setTargetLineDirectiveMode */
spSetTargetLineDirectiveMode :: (request: *SlangCompileRequest, targetIndex: s32, mode: SlangLineDirectiveMode) -> void #foreign slang;

/*! @see slang::ICompileRequest::setTargetLineDirectiveMode */
spSetTargetForceGLSLScalarBufferLayout :: (request: *SlangCompileRequest, targetIndex: s32, forceScalarLayout: bool) -> void #foreign slang;

/*! @see slang::ICompileRequest::setTargetUseMinimumSlangOptimization */
spSetTargetUseMinimumSlangOptimization :: (request: *ICompileRequest, targetIndex: s32, val: bool) -> void #foreign slang;

/*! @see slang::ICompileRequest::setIgnoreCapabilityCheck */
spSetIgnoreCapabilityCheck :: (request: *ICompileRequest, val: bool) -> void #foreign slang;

/*! @see slang::ICompileRequest::setCodeGenTarget */
spSetCodeGenTarget :: (request: *SlangCompileRequest, target: SlangCompileTarget) -> void #foreign slang;

/*! @see slang::ICompileRequest::addCodeGenTarget */
spAddCodeGenTarget :: (request: *SlangCompileRequest, target: SlangCompileTarget) -> s32 #foreign slang;

/*! @see slang::ICompileRequest::setTargetProfile */
spSetTargetProfile :: (request: *SlangCompileRequest, targetIndex: s32, profile: SlangProfileID) -> void #foreign slang;

/*! @see slang::ICompileRequest::setTargetFlags */
spSetTargetFlags :: (request: *SlangCompileRequest, targetIndex: s32, flags: SlangTargetFlags) -> void #foreign slang;

/*! @see slang::ICompileRequest::setTargetFloatingPointMode */
spSetTargetFloatingPointMode :: (request: *SlangCompileRequest, targetIndex: s32, mode: SlangFloatingPointMode) -> void #foreign slang;

/*! @see slang::ICompileRequest::addTargetCapability */
spAddTargetCapability :: (request: *ICompileRequest, targetIndex: s32, capability: SlangCapabilityID) -> void #foreign slang;

/* DEPRECATED: use `spSetMatrixLayoutMode` instead. */
spSetTargetMatrixLayoutMode :: (request: *SlangCompileRequest, targetIndex: s32, mode: SlangMatrixLayoutMode) -> void #foreign slang;

/*! @see slang::ICompileRequest::setMatrixLayoutMode */
spSetMatrixLayoutMode :: (request: *SlangCompileRequest, mode: SlangMatrixLayoutMode) -> void #foreign slang;

/*! @see slang::ICompileRequest::setDebugInfoLevel */
spSetDebugInfoLevel :: (request: *SlangCompileRequest, level: SlangDebugInfoLevel) -> void #foreign slang;

/*! @see slang::ICompileRequest::setDebugInfoFormat */
spSetDebugInfoFormat :: (request: *SlangCompileRequest, format: SlangDebugInfoFormat) -> void #foreign slang;

/*! @see slang::ICompileRequest::setOptimizationLevel */
spSetOptimizationLevel :: (request: *SlangCompileRequest, level: SlangOptimizationLevel) -> void #foreign slang;

/*! @see slang::ICompileRequest::setOutputContainerFormat */
spSetOutputContainerFormat :: (request: *SlangCompileRequest, format: SlangContainerFormat) -> void #foreign slang;

/*! @see slang::ICompileRequest::setPassThrough */
spSetPassThrough :: (request: *SlangCompileRequest, passThrough: SlangPassThrough) -> void #foreign slang;

/*! @see slang::ICompileRequest::setDiagnosticCallback */
spSetDiagnosticCallback :: (request: *SlangCompileRequest, callback: SlangDiagnosticCallback, userData: *void) -> void #foreign slang;

/*! @see slang::ICompileRequest::setWriter */
spSetWriter :: (request: *SlangCompileRequest, channel: SlangWriterChannel, writer: *ISlangWriter) -> void #foreign slang;

/*! @see slang::ICompileRequest::getWriter */
spGetWriter :: (request: *SlangCompileRequest, channel: SlangWriterChannel) -> *ISlangWriter #foreign slang;

/*! @see slang::ICompileRequest::addSearchPath */
spAddSearchPath :: (request: *SlangCompileRequest, searchDir: *u8) -> void #foreign slang;

/*! @see slang::ICompileRequest::addPreprocessorDefine */
spAddPreprocessorDefine :: (request: *SlangCompileRequest, key: *u8, value: *u8) -> void #foreign slang;

/*! @see slang::ICompileRequest::processCommandLineArguments */
spProcessCommandLineArguments :: (request: *SlangCompileRequest, args: **u8, argCount: s32) -> SlangResult #foreign slang;

/*! @see slang::ICompileRequest::addTranslationUnit */
spAddTranslationUnit :: (request: *SlangCompileRequest, language: SlangSourceLanguage, name: *u8) -> s32 #foreign slang;

/*! @see slang::ICompileRequest::setDefaultModuleName */
spSetDefaultModuleName :: (request: *SlangCompileRequest, defaultModuleName: *u8) -> void #foreign slang;

/*! @see slang::ICompileRequest::addPreprocessorDefine */
spTranslationUnit_addPreprocessorDefine :: (request: *SlangCompileRequest, translationUnitIndex: s32, key: *u8, value: *u8) -> void #foreign slang;

/*! @see slang::ICompileRequest::addTranslationUnitSourceFile */
spAddTranslationUnitSourceFile :: (request: *SlangCompileRequest, translationUnitIndex: s32, path: *u8) -> void #foreign slang;

/*! @see slang::ICompileRequest::addTranslationUnitSourceString */
spAddTranslationUnitSourceString :: (request: *SlangCompileRequest, translationUnitIndex: s32, path: *u8, source: *u8) -> void #foreign slang;

/*! @see slang::ICompileRequest::addLibraryReference */
spAddLibraryReference :: (request: *SlangCompileRequest, basePath: *u8, libData: *void, libDataSize: u64) -> SlangResult #foreign slang;

/*! @see slang::ICompileRequest::addTranslationUnitSourceStringSpan */
spAddTranslationUnitSourceStringSpan :: (request: *SlangCompileRequest, translationUnitIndex: s32, path: *u8, sourceBegin: *u8, sourceEnd: *u8) -> void #foreign slang;

/*! @see slang::ICompileRequest::addTranslationUnitSourceBlob */
spAddTranslationUnitSourceBlob :: (request: *SlangCompileRequest, translationUnitIndex: s32, path: *u8, sourceBlob: *ISlangBlob) -> void #foreign slang;

/*! @see slang::IGlobalSession::findProfile */
spFindProfile :: (session: *SlangSession, name: *u8) -> SlangProfileID #foreign slang;

/*! @see slang::IGlobalSession::findCapability */
spFindCapability :: (session: *SlangSession, name: *u8) -> SlangCapabilityID #foreign slang;

/*! @see slang::ICompileRequest::addEntryPoint */
spAddEntryPoint :: (request: *SlangCompileRequest, translationUnitIndex: s32, name: *u8, stage: SlangStage) -> s32 #foreign slang;

/*! @see slang::ICompileRequest::addEntryPointEx */
spAddEntryPointEx :: (request: *SlangCompileRequest, translationUnitIndex: s32, name: *u8, stage: SlangStage, genericArgCount: s32, genericArgs: **u8) -> s32 #foreign slang;

/*! @see slang::ICompileRequest::setGlobalGenericArgs */
spSetGlobalGenericArgs :: (request: *SlangCompileRequest, genericArgCount: s32, genericArgs: **u8) -> SlangResult #foreign slang;

/*! @see slang::ICompileRequest::setTypeNameForGlobalExistentialTypeParam */
spSetTypeNameForGlobalExistentialTypeParam :: (request: *SlangCompileRequest, slotIndex: s32, typeName: *u8) -> SlangResult #foreign slang;

/*! @see slang::ICompileRequest::setTypeNameForEntryPointExistentialTypeParam */
spSetTypeNameForEntryPointExistentialTypeParam :: (request: *SlangCompileRequest, entryPointIndex: s32, slotIndex: s32, typeName: *u8) -> SlangResult #foreign slang;

/*! @see slang::ICompileRequest::compile */
spCompile :: (request: *SlangCompileRequest) -> SlangResult #foreign slang;

/*! @see slang::ICompileRequest::getDiagnosticOutput */
spGetDiagnosticOutput :: (request: *SlangCompileRequest) -> *u8 #foreign slang;

/*! @see slang::ICompileRequest::getDiagnosticOutputBlob */
spGetDiagnosticOutputBlob :: (request: *SlangCompileRequest, outBlob: **ISlangBlob) -> SlangResult #foreign slang;

/*! @see slang::ICompileRequest::getDependencyFileCount */
spGetDependencyFileCount :: (request: *SlangCompileRequest) -> s32 #foreign slang;

/*! @see slang::ICompileRequest::getDependencyFilePath */
spGetDependencyFilePath :: (request: *SlangCompileRequest, index: s32) -> *u8 #foreign slang;

/*! @see slang::ICompileRequest::getTranslationUnitCount */
spGetTranslationUnitCount :: (request: *SlangCompileRequest) -> s32 #foreign slang;

/*! @see slang::ICompileRequest::getEntryPointSource */
spGetEntryPointSource :: (request: *SlangCompileRequest, entryPointIndex: s32) -> *u8 #foreign slang;

/*! @see slang::ICompileRequest::getEntryPointCode */
spGetEntryPointCode :: (request: *SlangCompileRequest, entryPointIndex: s32, outSize: *u64) -> *void #foreign slang;

/*! @see slang::ICompileRequest::getEntryPointCodeBlob */
spGetEntryPointCodeBlob :: (request: *SlangCompileRequest, entryPointIndex: s32, targetIndex: s32, outBlob: **ISlangBlob) -> SlangResult #foreign slang;

/*! @see slang::ICompileRequest::getEntryPointHostCallable */
spGetEntryPointHostCallable :: (request: *SlangCompileRequest, entryPointIndex: s32, targetIndex: s32, outSharedLibrary: **ISlangSharedLibrary) -> SlangResult #foreign slang;

/*! @see slang::ICompileRequest::getTargetCodeBlob */
spGetTargetCodeBlob :: (request: *SlangCompileRequest, targetIndex: s32, outBlob: **ISlangBlob) -> SlangResult #foreign slang;

/*! @see slang::ICompileRequest::getTargetHostCallable */
spGetTargetHostCallable :: (request: *SlangCompileRequest, targetIndex: s32, outSharedLibrary: **ISlangSharedLibrary) -> SlangResult #foreign slang;

/*! @see slang::ICompileRequest::getCompileRequestCode */
spGetCompileRequestCode :: (request: *SlangCompileRequest, outSize: *u64) -> *void #foreign slang;

/*! @see slang::ICompileRequest::getContainerCode */
spGetContainerCode :: (request: *SlangCompileRequest, outBlob: **ISlangBlob) -> SlangResult #foreign slang;

/*! @see slang::ICompileRequest::loadRepro */
spLoadRepro :: (request: *SlangCompileRequest, fileSystem: *ISlangFileSystem, data: *void, size: u64) -> SlangResult #foreign slang;

/*! @see slang::ICompileRequest::saveRepro */
spSaveRepro :: (request: *SlangCompileRequest, outBlob: **ISlangBlob) -> SlangResult #foreign slang;

/*! @see slang::ICompileRequest::enableReproCapture */
spEnableReproCapture :: (request: *SlangCompileRequest) -> SlangResult #foreign slang;

/*! @see slang::ICompileRequest::getCompileTimeProfile */
spGetCompileTimeProfile :: (request: *SlangCompileRequest, compileTimeProfile: **ISlangProfiler, shouldClear: bool) -> SlangResult #foreign slang;

/** Extract contents of a repro.

Writes the contained files and manifest with their 'unique' names into fileSystem. For more
details read the docs/repro.md documentation.

@param session          The slang session
@param reproData        Holds the repro data
@param reproDataSize    The size of the repro data
@param fileSystem       File system that the contents of the repro will be written to
@returns                A `SlangResult` to indicate success or failure.
*/
spExtractRepro :: (session: *SlangSession, reproData: *void, reproDataSize: u64, fileSystem: *ISlangMutableFileSystem) -> SlangResult #foreign slang;

/* Turns a repro into a file system.

Makes the contents of the repro available as a file system - that is able to access the files
with the same paths as were used on the original repro file system.

@param session          The slang session
@param reproData        The repro data
@param reproDataSize    The size of the repro data
@param replaceFileSystem  Will attempt to load by unique names from this file system before
using contents of the repro. Optional.
@param outFileSystem    The file system that can be used to access contents
@returns                A `SlangResult` to indicate success or failure.
*/
spLoadReproAsFileSystem :: (session: *SlangSession, reproData: *void, reproDataSize: u64, replaceFileSystem: *ISlangFileSystem, outFileSystem: **ISlangFileSystemExt) -> SlangResult #foreign slang;

/*! @see slang::ICompileRequest::overrideDiagnosticSeverity */
spOverrideDiagnosticSeverity :: (request: *SlangCompileRequest, messageID: SlangInt, overrideSeverity: SlangSeverity) -> void #foreign slang;

/*! @see slang::ICompileRequest::getDiagnosticFlags */
spGetDiagnosticFlags :: (request: *SlangCompileRequest) -> SlangDiagnosticFlags #foreign slang;

/*! @see slang::ICompileRequest::setDiagnosticFlags */
spSetDiagnosticFlags :: (request: *SlangCompileRequest, flags: SlangDiagnosticFlags) -> void #foreign slang;

// get reflection data from a compilation request
spGetReflection :: (request: *SlangCompileRequest) -> *SlangReflection #foreign slang;

// User Attribute
spReflectionUserAttribute_GetName :: (attrib: *SlangReflectionUserAttribute) -> *u8 #foreign slang;
spReflectionUserAttribute_GetArgumentCount :: (attrib: *SlangReflectionUserAttribute) -> u32 #foreign slang;

spReflectionUserAttribute_GetArgumentType :: (attrib: *SlangReflectionUserAttribute, index: u32) -> *SlangReflectionType #foreign slang;

spReflectionUserAttribute_GetArgumentValueInt :: (attrib: *SlangReflectionUserAttribute, index: u32, rs: *s32) -> SlangResult #foreign slang;

spReflectionUserAttribute_GetArgumentValueFloat :: (attrib: *SlangReflectionUserAttribute, index: u32, rs: *float) -> SlangResult #foreign slang;

/** Returns the string-typed value of a user attribute argument
The string returned is not null-terminated. The length of the string is returned via
`outSize`. If index of out of range, or if the specified argument is not a string, the
function will return nullptr.
*/
spReflectionUserAttribute_GetArgumentValueString :: (attrib: *SlangReflectionUserAttribute, index: u32, outSize: *u64) -> *u8 #foreign slang;

// Type Reflection
spReflectionType_GetKind :: (type: *SlangReflectionType) -> SlangTypeKind #foreign slang;
spReflectionType_GetUserAttributeCount :: (type: *SlangReflectionType) -> u32 #foreign slang;
spReflectionType_GetUserAttribute :: (type: *SlangReflectionType, index: u32) -> *SlangReflectionUserAttribute #foreign slang;

spReflectionType_FindUserAttributeByName :: (type: *SlangReflectionType, name: *u8) -> *SlangReflectionUserAttribute #foreign slang;

spReflectionType_applySpecializations :: (type: *SlangReflectionType, generic: *SlangReflectionGeneric) -> *SlangReflectionType #foreign slang;

spReflectionType_GetFieldCount :: (type: *SlangReflectionType) -> u32 #foreign slang;
spReflectionType_GetFieldByIndex :: (type: *SlangReflectionType, index: u32) -> *SlangReflectionVariable #foreign slang;

/** Returns the number of elements in the given type.

This operation is valid for vector and array types. For other types it returns zero.

When invoked on an unbounded-size array it will return `SLANG_UNBOUNDED_SIZE`,
which is defined to be `~size_t(0)`.

If the size of a type cannot be statically computed, perhaps because it depends on
a generic parameter that has not been bound to a specific value, this function returns zero.

Use spReflectionType_GetSpecializedElementCount if the size is dependent on
a link time constant
*/
spReflectionType_GetElementCount :: (type: *SlangReflectionType) -> u64 #foreign slang;

/** The same as spReflectionType_GetElementCount except it takes into account specialization
* information from the given reflection info
*/
spReflectionType_GetSpecializedElementCount :: (type: *SlangReflectionType, reflection: *SlangReflection) -> u64 #foreign slang;

spReflectionType_GetElementType :: (type: *SlangReflectionType) -> *SlangReflectionType #foreign slang;

spReflectionType_GetRowCount :: (type: *SlangReflectionType) -> u32 #foreign slang;
spReflectionType_GetColumnCount :: (type: *SlangReflectionType) -> u32 #foreign slang;
spReflectionType_GetScalarType :: (type: *SlangReflectionType) -> SlangScalarType #foreign slang;

spReflectionType_GetResourceShape :: (type: *SlangReflectionType) -> SlangResourceShape #foreign slang;
spReflectionType_GetResourceAccess :: (type: *SlangReflectionType) -> SlangResourceAccess #foreign slang;
spReflectionType_GetResourceResultType :: (type: *SlangReflectionType) -> *SlangReflectionType #foreign slang;

spReflectionType_GetName :: (type: *SlangReflectionType) -> *u8 #foreign slang;

spReflectionType_GetFullName :: (type: *SlangReflectionType, outNameBlob: **ISlangBlob) -> SlangResult #foreign slang;
spReflectionType_GetGenericContainer :: (type: *SlangReflectionType) -> *SlangReflectionGeneric #foreign slang;

// Type Layout Reflection
spReflectionTypeLayout_GetType :: (type: *SlangReflectionTypeLayout) -> *SlangReflectionType #foreign slang;
spReflectionTypeLayout_getKind :: (type: *SlangReflectionTypeLayout) -> SlangTypeKind #foreign slang;
spReflectionTypeLayout_GetSize :: (type: *SlangReflectionTypeLayout, category: SlangParameterCategory) -> u64 #foreign slang;

spReflectionTypeLayout_GetStride :: (type: *SlangReflectionTypeLayout, category: SlangParameterCategory) -> u64 #foreign slang;

spReflectionTypeLayout_getAlignment :: (type: *SlangReflectionTypeLayout, category: SlangParameterCategory) -> s32 #foreign slang;

spReflectionTypeLayout_GetFieldCount :: (type: *SlangReflectionTypeLayout) -> u32 #foreign slang;
spReflectionTypeLayout_GetFieldByIndex :: (type: *SlangReflectionTypeLayout, index: u32) -> *SlangReflectionVariableLayout #foreign slang;

spReflectionTypeLayout_findFieldIndexByName :: (typeLayout: *SlangReflectionTypeLayout, nameBegin: *u8, nameEnd: *u8) -> SlangInt #foreign slang;

spReflectionTypeLayout_GetExplicitCounter :: (typeLayout: *SlangReflectionTypeLayout) -> *SlangReflectionVariableLayout #foreign slang;

spReflectionTypeLayout_GetElementStride :: (type: *SlangReflectionTypeLayout, category: SlangParameterCategory) -> u64 #foreign slang;

spReflectionTypeLayout_GetElementTypeLayout :: (type: *SlangReflectionTypeLayout) -> *SlangReflectionTypeLayout #foreign slang;

spReflectionTypeLayout_GetElementVarLayout :: (type: *SlangReflectionTypeLayout) -> *SlangReflectionVariableLayout #foreign slang;

spReflectionTypeLayout_getContainerVarLayout :: (type: *SlangReflectionTypeLayout) -> *SlangReflectionVariableLayout #foreign slang;

spReflectionTypeLayout_GetParameterCategory :: (type: *SlangReflectionTypeLayout) -> SlangParameterCategory #foreign slang;

spReflectionTypeLayout_GetCategoryCount :: (type: *SlangReflectionTypeLayout) -> u32 #foreign slang;

spReflectionTypeLayout_GetCategoryByIndex :: (type: *SlangReflectionTypeLayout, index: u32) -> SlangParameterCategory #foreign slang;

spReflectionTypeLayout_GetMatrixLayoutMode :: (type: *SlangReflectionTypeLayout) -> SlangMatrixLayoutMode #foreign slang;

spReflectionTypeLayout_getGenericParamIndex :: (type: *SlangReflectionTypeLayout) -> s32 #foreign slang;

spReflectionTypeLayout_getPendingDataTypeLayout :: (type: *SlangReflectionTypeLayout) -> *SlangReflectionTypeLayout #foreign slang;

spReflectionTypeLayout_getSpecializedTypePendingDataVarLayout :: (type: *SlangReflectionTypeLayout) -> *SlangReflectionVariableLayout #foreign slang;
spReflectionType_getSpecializedTypeArgCount :: (type: *SlangReflectionType) -> SlangInt #foreign slang;
spReflectionType_getSpecializedTypeArgType :: (type: *SlangReflectionType, index: SlangInt) -> *SlangReflectionType #foreign slang;

spReflectionTypeLayout_getBindingRangeCount :: (typeLayout: *SlangReflectionTypeLayout) -> SlangInt #foreign slang;
spReflectionTypeLayout_getBindingRangeType :: (typeLayout: *SlangReflectionTypeLayout, index: SlangInt) -> SlangBindingType #foreign slang;

spReflectionTypeLayout_isBindingRangeSpecializable :: (typeLayout: *SlangReflectionTypeLayout, index: SlangInt) -> SlangInt #foreign slang;

spReflectionTypeLayout_getBindingRangeBindingCount :: (typeLayout: *SlangReflectionTypeLayout, index: SlangInt) -> SlangInt #foreign slang;

spReflectionTypeLayout_getBindingRangeLeafTypeLayout :: (typeLayout: *SlangReflectionTypeLayout, index: SlangInt) -> *SlangReflectionTypeLayout #foreign slang;

spReflectionTypeLayout_getBindingRangeLeafVariable :: (typeLayout: *SlangReflectionTypeLayout, index: SlangInt) -> *SlangReflectionVariable #foreign slang;

spReflectionTypeLayout_getBindingRangeImageFormat :: (typeLayout: *SlangReflectionTypeLayout, index: SlangInt) -> SlangImageFormat #foreign slang;

spReflectionTypeLayout_getFieldBindingRangeOffset :: (typeLayout: *SlangReflectionTypeLayout, fieldIndex: SlangInt) -> SlangInt #foreign slang;

spReflectionTypeLayout_getExplicitCounterBindingRangeOffset :: (inTypeLayout: *SlangReflectionTypeLayout) -> SlangInt #foreign slang;

spReflectionTypeLayout_getBindingRangeDescriptorSetIndex :: (typeLayout: *SlangReflectionTypeLayout, index: SlangInt) -> SlangInt #foreign slang;

spReflectionTypeLayout_getBindingRangeFirstDescriptorRangeIndex :: (typeLayout: *SlangReflectionTypeLayout, index: SlangInt) -> SlangInt #foreign slang;

spReflectionTypeLayout_getBindingRangeDescriptorRangeCount :: (typeLayout: *SlangReflectionTypeLayout, index: SlangInt) -> SlangInt #foreign slang;

spReflectionTypeLayout_getDescriptorSetCount :: (typeLayout: *SlangReflectionTypeLayout) -> SlangInt #foreign slang;
spReflectionTypeLayout_getDescriptorSetSpaceOffset :: (typeLayout: *SlangReflectionTypeLayout, setIndex: SlangInt) -> SlangInt #foreign slang;

spReflectionTypeLayout_getDescriptorSetDescriptorRangeCount :: (typeLayout: *SlangReflectionTypeLayout, setIndex: SlangInt) -> SlangInt #foreign slang;

spReflectionTypeLayout_getDescriptorSetDescriptorRangeIndexOffset :: (typeLayout: *SlangReflectionTypeLayout, setIndex: SlangInt, rangeIndex: SlangInt) -> SlangInt #foreign slang;

spReflectionTypeLayout_getDescriptorSetDescriptorRangeDescriptorCount :: (typeLayout: *SlangReflectionTypeLayout, setIndex: SlangInt, rangeIndex: SlangInt) -> SlangInt #foreign slang;

spReflectionTypeLayout_getDescriptorSetDescriptorRangeType :: (typeLayout: *SlangReflectionTypeLayout, setIndex: SlangInt, rangeIndex: SlangInt) -> SlangBindingType #foreign slang;

spReflectionTypeLayout_getDescriptorSetDescriptorRangeCategory :: (typeLayout: *SlangReflectionTypeLayout, setIndex: SlangInt, rangeIndex: SlangInt) -> SlangParameterCategory #foreign slang;

spReflectionTypeLayout_getSubObjectRangeCount :: (typeLayout: *SlangReflectionTypeLayout) -> SlangInt #foreign slang;
spReflectionTypeLayout_getSubObjectRangeBindingRangeIndex :: (typeLayout: *SlangReflectionTypeLayout, subObjectRangeIndex: SlangInt) -> SlangInt #foreign slang;

spReflectionTypeLayout_getSubObjectRangeSpaceOffset :: (typeLayout: *SlangReflectionTypeLayout, subObjectRangeIndex: SlangInt) -> SlangInt #foreign slang;

spReflectionTypeLayout_getSubObjectRangeOffset :: (typeLayout: *SlangReflectionTypeLayout, subObjectRangeIndex: SlangInt) -> *SlangReflectionVariableLayout #foreign slang;

// Variable Reflection
spReflectionVariable_GetName :: (var: *SlangReflectionVariable) -> *u8 #foreign slang;
spReflectionVariable_GetType :: (var: *SlangReflectionVariable) -> *SlangReflectionType #foreign slang;
spReflectionVariable_FindModifier :: (var: *SlangReflectionVariable, modifierID: SlangModifierID) -> *SlangReflectionModifier #foreign slang;

spReflectionVariable_GetUserAttributeCount :: (var: *SlangReflectionVariable) -> u32 #foreign slang;
spReflectionVariable_GetUserAttribute :: (var: *SlangReflectionVariable, index: u32) -> *SlangReflectionUserAttribute #foreign slang;

spReflectionVariable_FindUserAttributeByName :: (var: *SlangReflectionVariable, globalSession: *SlangSession, name: *u8) -> *SlangReflectionUserAttribute #foreign slang;

spReflectionVariable_HasDefaultValue :: (inVar: *SlangReflectionVariable) -> bool #foreign slang;

spReflectionVariable_GetDefaultValueInt :: (inVar: *SlangReflectionVariable, rs: *s64) -> SlangResult #foreign slang;
spReflectionVariable_GetGenericContainer :: (var: *SlangReflectionVariable) -> *SlangReflectionGeneric #foreign slang;

spReflectionVariable_applySpecializations :: (var: *SlangReflectionVariable, generic: *SlangReflectionGeneric) -> *SlangReflectionVariable #foreign slang;

// Variable Layout Reflection
spReflectionVariableLayout_GetVariable :: (var: *SlangReflectionVariableLayout) -> *SlangReflectionVariable #foreign slang;

spReflectionVariableLayout_GetTypeLayout :: (var: *SlangReflectionVariableLayout) -> *SlangReflectionTypeLayout #foreign slang;

spReflectionVariableLayout_GetOffset :: (var: *SlangReflectionVariableLayout, category: SlangParameterCategory) -> u64 #foreign slang;

spReflectionVariableLayout_GetSpace :: (var: *SlangReflectionVariableLayout, category: SlangParameterCategory) -> u64 #foreign slang;

spReflectionVariableLayout_GetImageFormat :: (var: *SlangReflectionVariableLayout) -> SlangImageFormat #foreign slang;

spReflectionVariableLayout_GetSemanticName :: (var: *SlangReflectionVariableLayout) -> *u8 #foreign slang;

spReflectionVariableLayout_GetSemanticIndex :: (var: *SlangReflectionVariableLayout) -> u64 #foreign slang;

// Function Reflection
spReflectionFunction_asDecl :: (func: *SlangReflectionFunction) -> *SlangReflectionDecl #foreign slang;
spReflectionFunction_GetName :: (func: *SlangReflectionFunction) -> *u8 #foreign slang;
spReflectionFunction_FindModifier :: (var: *SlangReflectionFunction, modifierID: SlangModifierID) -> *SlangReflectionModifier #foreign slang;

spReflectionFunction_GetUserAttributeCount :: (func: *SlangReflectionFunction) -> u32 #foreign slang;

spReflectionFunction_GetUserAttribute :: (func: *SlangReflectionFunction, index: u32) -> *SlangReflectionUserAttribute #foreign slang;

spReflectionFunction_FindUserAttributeByName :: (func: *SlangReflectionFunction, globalSession: *SlangSession, name: *u8) -> *SlangReflectionUserAttribute #foreign slang;

spReflectionFunction_GetParameterCount :: (func: *SlangReflectionFunction) -> u32 #foreign slang;
spReflectionFunction_GetParameter :: (func: *SlangReflectionFunction, index: u32) -> *SlangReflectionVariable #foreign slang;

spReflectionFunction_GetResultType :: (func: *SlangReflectionFunction) -> *SlangReflectionType #foreign slang;

spReflectionFunction_GetGenericContainer :: (func: *SlangReflectionFunction) -> *SlangReflectionGeneric #foreign slang;

spReflectionFunction_applySpecializations :: (func: *SlangReflectionFunction, generic: *SlangReflectionGeneric) -> *SlangReflectionFunction #foreign slang;

spReflectionFunction_specializeWithArgTypes :: (func: *SlangReflectionFunction, argTypeCount: SlangInt, argTypes: **SlangReflectionType) -> *SlangReflectionFunction #foreign slang;

spReflectionFunction_isOverloaded :: (func: *SlangReflectionFunction) -> bool #foreign slang;
spReflectionFunction_getOverloadCount :: (func: *SlangReflectionFunction) -> u32 #foreign slang;
spReflectionFunction_getOverload :: (func: *SlangReflectionFunction, index: u32) -> *SlangReflectionFunction #foreign slang;

// Abstract Decl Reflection
spReflectionDecl_getChildrenCount :: (parentDecl: *SlangReflectionDecl) -> u32 #foreign slang;
spReflectionDecl_getChild :: (parentDecl: *SlangReflectionDecl, index: u32) -> *SlangReflectionDecl #foreign slang;

spReflectionDecl_getName :: (decl: *SlangReflectionDecl) -> *u8 #foreign slang;
spReflectionDecl_getKind :: (decl: *SlangReflectionDecl) -> SlangDeclKind #foreign slang;
spReflectionDecl_castToFunction :: (decl: *SlangReflectionDecl) -> *SlangReflectionFunction #foreign slang;
spReflectionDecl_castToVariable :: (decl: *SlangReflectionDecl) -> *SlangReflectionVariable #foreign slang;
spReflectionDecl_castToGeneric :: (decl: *SlangReflectionDecl) -> *SlangReflectionGeneric #foreign slang;
spReflection_getTypeFromDecl :: (decl: *SlangReflectionDecl) -> *SlangReflectionType #foreign slang;
spReflectionDecl_getParent :: (decl: *SlangReflectionDecl) -> *SlangReflectionDecl #foreign slang;

// Generic Reflection
spReflectionGeneric_asDecl :: (generic: *SlangReflectionGeneric) -> *SlangReflectionDecl #foreign slang;
spReflectionGeneric_GetName :: (generic: *SlangReflectionGeneric) -> *u8 #foreign slang;
spReflectionGeneric_GetTypeParameterCount :: (generic: *SlangReflectionGeneric) -> u32 #foreign slang;

spReflectionGeneric_GetTypeParameter :: (generic: *SlangReflectionGeneric, index: u32) -> *SlangReflectionVariable #foreign slang;

spReflectionGeneric_GetValueParameterCount :: (generic: *SlangReflectionGeneric) -> u32 #foreign slang;

spReflectionGeneric_GetValueParameter :: (generic: *SlangReflectionGeneric, index: u32) -> *SlangReflectionVariable #foreign slang;

spReflectionGeneric_GetTypeParameterConstraintCount :: (generic: *SlangReflectionGeneric, typeParam: *SlangReflectionVariable) -> u32 #foreign slang;

spReflectionGeneric_GetTypeParameterConstraintType :: (generic: *SlangReflectionGeneric, typeParam: *SlangReflectionVariable, index: u32) -> *SlangReflectionType #foreign slang;

spReflectionGeneric_GetInnerKind :: (generic: *SlangReflectionGeneric) -> SlangDeclKind #foreign slang;
spReflectionGeneric_GetInnerDecl :: (generic: *SlangReflectionGeneric) -> *SlangReflectionDecl #foreign slang;

spReflectionGeneric_GetOuterGenericContainer :: (generic: *SlangReflectionGeneric) -> *SlangReflectionGeneric #foreign slang;

spReflectionGeneric_GetConcreteType :: (generic: *SlangReflectionGeneric, typeParam: *SlangReflectionVariable) -> *SlangReflectionType #foreign slang;

spReflectionGeneric_GetConcreteIntVal :: (generic: *SlangReflectionGeneric, valueParam: *SlangReflectionVariable) -> s64 #foreign slang;

spReflectionGeneric_applySpecializations :: (currGeneric: *SlangReflectionGeneric, generic: *SlangReflectionGeneric) -> *SlangReflectionGeneric #foreign slang;

/** Get the stage that a variable belongs to (if any).

A variable "belongs" to a specific stage when it is a varying input/output
parameter either defined as part of the parameter list for an entry
point *or* at the global scope of a stage-specific GLSL code file (e.g.,
an `in` parameter in a GLSL `.vs` file belongs to the vertex stage).
*/
spReflectionVariableLayout_getStage :: (var: *SlangReflectionVariableLayout) -> SlangStage #foreign slang;

spReflectionVariableLayout_getPendingDataLayout :: (var: *SlangReflectionVariableLayout) -> *SlangReflectionVariableLayout #foreign slang;

// Shader Parameter Reflection
spReflectionParameter_GetBindingIndex :: (parameter: *SlangReflectionParameter) -> u32 #foreign slang;
spReflectionParameter_GetBindingSpace :: (parameter: *SlangReflectionParameter) -> u32 #foreign slang;

spIsParameterLocationUsed :: (request: *SlangCompileRequest, entryPointIndex: SlangInt, targetIndex: SlangInt, category: SlangParameterCategory, spaceIndex: SlangUInt, registerIndex: SlangUInt, outUsed: *bool) -> SlangResult #foreign slang;

// Entry Point Reflection
spReflectionEntryPoint_getName :: (entryPoint: *SlangReflectionEntryPoint) -> *u8 #foreign slang;

spReflectionEntryPoint_getNameOverride :: (entryPoint: *SlangReflectionEntryPoint) -> *u8 #foreign slang;

spReflectionEntryPoint_getFunction :: (entryPoint: *SlangReflectionEntryPoint) -> *SlangReflectionFunction #foreign slang;

spReflectionEntryPoint_getParameterCount :: (entryPoint: *SlangReflectionEntryPoint) -> u32 #foreign slang;

spReflectionEntryPoint_getParameterByIndex :: (entryPoint: *SlangReflectionEntryPoint, index: u32) -> *SlangReflectionVariableLayout #foreign slang;

spReflectionEntryPoint_getStage :: (entryPoint: *SlangReflectionEntryPoint) -> SlangStage #foreign slang;

spReflectionEntryPoint_getComputeThreadGroupSize :: (entryPoint: *SlangReflectionEntryPoint, axisCount: SlangUInt, outSizeAlongAxis: *SlangUInt) -> void #foreign slang;

spReflectionEntryPoint_getComputeWaveSize :: (entryPoint: *SlangReflectionEntryPoint, outWaveSize: *SlangUInt) -> void #foreign slang;

spReflectionEntryPoint_usesAnySampleRateInput :: (entryPoint: *SlangReflectionEntryPoint) -> s32 #foreign slang;

spReflectionEntryPoint_getVarLayout :: (entryPoint: *SlangReflectionEntryPoint) -> *SlangReflectionVariableLayout #foreign slang;

spReflectionEntryPoint_getResultVarLayout :: (entryPoint: *SlangReflectionEntryPoint) -> *SlangReflectionVariableLayout #foreign slang;

spReflectionEntryPoint_hasDefaultConstantBuffer :: (entryPoint: *SlangReflectionEntryPoint) -> s32 #foreign slang;

// SlangReflectionTypeParameter
spReflectionTypeParameter_GetName :: (typeParam: *SlangReflectionTypeParameter) -> *u8 #foreign slang;

spReflectionTypeParameter_GetIndex :: (typeParam: *SlangReflectionTypeParameter) -> u32 #foreign slang;
spReflectionTypeParameter_GetConstraintCount :: (typeParam: *SlangReflectionTypeParameter) -> u32 #foreign slang;

spReflectionTypeParameter_GetConstraintByIndex :: (typeParam: *SlangReflectionTypeParameter, index: u32) -> *SlangReflectionType #foreign slang;

// Shader Reflection
spReflection_ToJson :: (reflection: *SlangReflection, request: *SlangCompileRequest, outBlob: **ISlangBlob) -> SlangResult #foreign slang;

spReflection_GetParameterCount :: (reflection: *SlangReflection) -> u32 #foreign slang;
spReflection_GetParameterByIndex :: (reflection: *SlangReflection, index: u32) -> *SlangReflectionParameter #foreign slang;

spReflection_GetTypeParameterCount :: (reflection: *SlangReflection) -> u32 #foreign slang;
spReflection_GetTypeParameterByIndex :: (reflection: *SlangReflection, index: u32) -> *SlangReflectionTypeParameter #foreign slang;

spReflection_FindTypeParameter :: (reflection: *SlangReflection, name: *u8) -> *SlangReflectionTypeParameter #foreign slang;

spReflection_FindTypeByName :: (reflection: *SlangReflection, name: *u8) -> *SlangReflectionType #foreign slang;

spReflection_GetTypeLayout :: (reflection: *SlangReflection, reflectionType: *SlangReflectionType, rules: SlangLayoutRules) -> *SlangReflectionTypeLayout #foreign slang;

spReflection_FindFunctionByName :: (reflection: *SlangReflection, name: *u8) -> *SlangReflectionFunction #foreign slang;

spReflection_FindFunctionByNameInType :: (reflection: *SlangReflection, reflType: *SlangReflectionType, name: *u8) -> *SlangReflectionFunction #foreign slang;

spReflection_FindVarByNameInType :: (reflection: *SlangReflection, reflType: *SlangReflectionType, name: *u8) -> *SlangReflectionVariable #foreign slang;

spReflection_getEntryPointCount :: (reflection: *SlangReflection) -> SlangUInt #foreign slang;
spReflection_getEntryPointByIndex :: (reflection: *SlangReflection, index: SlangUInt) -> *SlangReflectionEntryPoint #foreign slang;

spReflection_findEntryPointByName :: (reflection: *SlangReflection, name: *u8) -> *SlangReflectionEntryPoint #foreign slang;

spReflection_getGlobalConstantBufferBinding :: (reflection: *SlangReflection) -> SlangUInt #foreign slang;
spReflection_getGlobalConstantBufferSize :: (reflection: *SlangReflection) -> u64 #foreign slang;

spReflection_specializeType :: (reflection: *SlangReflection, type: *SlangReflectionType, specializationArgCount: SlangInt, specializationArgs: **SlangReflectionType, outDiagnostics: **ISlangBlob) -> *SlangReflectionType #foreign slang;

spReflection_specializeGeneric :: (inProgramLayout: *SlangReflection, generic: *SlangReflectionGeneric, argCount: SlangInt, argTypes: *SlangReflectionGenericArgType, args: *SlangReflectionGenericArg, outDiagnostics: **ISlangBlob) -> *SlangReflectionGeneric #foreign slang;

spReflection_isSubType :: (reflection: *SlangReflection, subType: *SlangReflectionType, superType: *SlangReflectionType) -> bool #foreign slang;

/// Get the number of hashed strings
spReflection_getHashedStringCount :: (reflection: *SlangReflection) -> SlangUInt #foreign slang;

/// Get a hashed string. The number of chars is written in outCount.
/// The count does *NOT* including terminating 0. The returned string will be 0 terminated.
spReflection_getHashedString :: (reflection: *SlangReflection, index: SlangUInt, outCount: *u64) -> *u8 #foreign slang;

/// Compute a string hash.
/// Count should *NOT* include terminating zero.
spComputeStringHash :: (chars: *u8, count: u64) -> SlangUInt32 #foreign slang;

/// Get a type layout representing reflection information for the global-scope parameters.
spReflection_getGlobalParamsTypeLayout :: (reflection: *SlangReflection) -> *SlangReflectionTypeLayout #foreign slang;

/// Get a variable layout representing reflection information for the global-scope parameters.
spReflection_getGlobalParamsVarLayout :: (reflection: *SlangReflection) -> *SlangReflectionVariableLayout #foreign slang;

spGetTranslationUnitSource :: (request: *SlangCompileRequest, translationUnitIndex: s32) -> *u8 #foreign slang;

spReflection_GetSession :: (reflection: *SlangReflection) -> *ISession #foreign slang "?spReflection_GetSession@@YAPEAUISession@slang@@PEAUSlangProgramLayout@@@Z";

/** @see slang::ICompileRequest::getProgram
*/
spCompileRequest_getProgram :: (request: *SlangCompileRequest, outProgram: **IComponentType) -> SlangResult #foreign slang;

/** @see slang::ICompileRequest::getProgramWithEntryPoints
*/
spCompileRequest_getProgramWithEntryPoints :: (request: *SlangCompileRequest, outProgram: **IComponentType) -> SlangResult #foreign slang;

/** @see slang::ICompileRequest::getEntryPoint
*/
spCompileRequest_getEntryPoint :: (request: *SlangCompileRequest, entryPointIndex: SlangInt, outEntryPoint: **IComponentType) -> SlangResult #foreign slang;

/** @see slang::ICompileRequest::getModule
*/
spCompileRequest_getModule :: (request: *SlangCompileRequest, translationUnitIndex: SlangInt, outModule: **IModule) -> SlangResult #foreign slang;

/** @see slang::ICompileRequest::getSession
*/
spCompileRequest_getSession :: (request: *SlangCompileRequest, outSession: **ISession) -> SlangResult #foreign slang;

SlangLanguageVersion :: enum s32 {
    LANGUAGE_VERSION_UNKNOWN :: 0;
    LANGUAGE_VERSION_LEGACY  :: 2018;
    LANGUAGE_VERSION_2025    :: 2025;
    LANGUAGE_VERSION_2026    :: 2026;
    LANGAUGE_VERSION_DEFAULT :: 2018;
    LANGUAGE_VERSION_LATEST  :: 2026;

    SLANG_LANGUAGE_VERSION_UNKNOWN :: LANGUAGE_VERSION_UNKNOWN;
    SLANG_LANGUAGE_VERSION_LEGACY  :: LANGUAGE_VERSION_LEGACY;
    SLANG_LANGUAGE_VERSION_2025    :: LANGUAGE_VERSION_2025;
    SLANG_LANGUAGE_VERSION_2026    :: LANGUAGE_VERSION_2026;
    SLANG_LANGAUGE_VERSION_DEFAULT :: LANGAUGE_VERSION_DEFAULT;
    SLANG_LANGUAGE_VERSION_LATEST  :: LANGUAGE_VERSION_LATEST;
}

/* Description of a Slang global session.
*/
SlangGlobalSessionDesc :: struct {
    /// Size of this struct.
    structureSize:      u32 = 80;

    /// Slang API version.
    apiVersion:         u32 = 0;

    /// Specify the oldest Slang language version that any sessions will use.
    minLanguageVersion: u32 = xx SlangLanguageVersion.LANGUAGE_VERSION_2025;

    /// Whether to enable GLSL support.
    enableGLSL          := false;

    /// Reserved for future use.
    reserved:           [16] u32;
}

/* Create a global session, with the built-in core module.

@param apiVersion Pass in SLANG_API_VERSION
@param outGlobalSession (out)The created global session.
*/
slang_createGlobalSession :: (apiVersion: SlangInt, outGlobalSession: **IGlobalSession) -> SlangResult #foreign slang;

/* Create a global session, with the built-in core module.

@param desc Description of the global session.
@param outGlobalSession (out)The created global session.
*/
slang_createGlobalSession2 :: (desc: *SlangGlobalSessionDesc, outGlobalSession: **IGlobalSession) -> SlangResult #foreign slang;

/* Create a global session, but do not set up the core module. The core module can
then be loaded via loadCoreModule or compileCoreModule

@param apiVersion Pass in SLANG_API_VERSION
@param outGlobalSession (out)The created global session that doesn't have a core module setup.

NOTE! API is experimental and not ready for production code
*/
slang_createGlobalSessionWithoutCoreModule :: (apiVersion: SlangInt, outGlobalSession: **IGlobalSession) -> SlangResult #foreign slang;

/* Returns a blob that contains the serialized core module.
Returns nullptr if there isn't an embedded core module.

NOTE! API is experimental and not ready for production code
*/
slang_getEmbeddedCoreModule :: () -> *ISlangBlob #foreign slang "?slang_getEmbeddedCoreModule@@YAPEAUISlangBlob@@XZ";

/* Cleanup all global allocations used by Slang, to prevent memory leak detectors from
reporting them as leaks. This function should only be called after all Slang objects
have been released. No other Slang functions such as `createGlobalSession`
should be called after this function.
*/
slang_shutdown :: () -> void #foreign slang;

/* Return the last signaled internal error message.
*/
slang_getLastInternalErrorMessage :: () -> *u8 #foreign slang;

/// Create a byte code runner that can execute Slang byte code.
slang_createByteCodeRunner :: (desc: *ByteCodeRunnerDesc, outByteCodeRunner: **IByteCodeRunner) -> SlangResult #foreign slang;

/// Disassemble a Slang byte code blob into human-readable text.
slang_disassembleByteCode :: (moduleBlob: *IBlob, outDisassemblyBlob: **IBlob) -> SlangResult #foreign slang;

#scope_file

#import "Basic"; // For assert


#run {
    {
        info := type_info(CompilerOptionValue);
        for info.members {
            if it.name == {
                case "kind";
                    assert(it.offset_in_bytes == 0, "CompilerOptionValue.kind has unexpected offset % instead of 0", it.offset_in_bytes);
                    assert(it.type.runtime_size == 4, "CompilerOptionValue.kind has unexpected size % instead of 4", it.type.runtime_size);
                case "intValue0";
                    assert(it.offset_in_bytes == 4, "CompilerOptionValue.intValue0 has unexpected offset % instead of 4", it.offset_in_bytes);
                    assert(it.type.runtime_size == 4, "CompilerOptionValue.intValue0 has unexpected size % instead of 4", it.type.runtime_size);
                case "intValue1";
                    assert(it.offset_in_bytes == 8, "CompilerOptionValue.intValue1 has unexpected offset % instead of 8", it.offset_in_bytes);
                    assert(it.type.runtime_size == 4, "CompilerOptionValue.intValue1 has unexpected size % instead of 4", it.type.runtime_size);
                case "stringValue0";
                    assert(it.offset_in_bytes == 16, "CompilerOptionValue.stringValue0 has unexpected offset % instead of 16", it.offset_in_bytes);
                    assert(it.type.runtime_size == 8, "CompilerOptionValue.stringValue0 has unexpected size % instead of 8", it.type.runtime_size);
                case "stringValue1";
                    assert(it.offset_in_bytes == 24, "CompilerOptionValue.stringValue1 has unexpected offset % instead of 24", it.offset_in_bytes);
                    assert(it.type.runtime_size == 8, "CompilerOptionValue.stringValue1 has unexpected size % instead of 8", it.type.runtime_size);
            }
        }
        assert(size_of(CompilerOptionValue) == 32, "CompilerOptionValue has size % instead of 32", size_of(CompilerOptionValue));
    }

    {
        info := type_info(CompilerOptionEntry);
        for info.members {
            if it.name == {
                case "name";
                    assert(it.offset_in_bytes == 0, "CompilerOptionEntry.name has unexpected offset % instead of 0", it.offset_in_bytes);
                    assert(it.type.runtime_size == 4, "CompilerOptionEntry.name has unexpected size % instead of 4", it.type.runtime_size);
                case "value";
                    assert(it.offset_in_bytes == 8, "CompilerOptionEntry.value has unexpected offset % instead of 8", it.offset_in_bytes);
                    assert(it.type.runtime_size == 32, "CompilerOptionEntry.value has unexpected size % instead of 32", it.type.runtime_size);
            }
        }
        assert(size_of(CompilerOptionEntry) == 40, "CompilerOptionEntry has size % instead of 40", size_of(CompilerOptionEntry));
    }

    assert(size_of(ICompileRequest) == 8, "ICompileRequest has size % instead of 8", size_of(ICompileRequest));

    {
        info := type_info(GenericArgReflection);
        for info.members {
            if it.name == {
                case "typeVal";
                    assert(it.offset_in_bytes == 0, "GenericArgReflection.typeVal has unexpected offset % instead of 0", it.offset_in_bytes);
                    assert(it.type.runtime_size == 8, "GenericArgReflection.typeVal has unexpected size % instead of 8", it.type.runtime_size);
                case "intVal";
                    assert(it.offset_in_bytes == 0, "GenericArgReflection.intVal has unexpected offset % instead of 0", it.offset_in_bytes);
                    assert(it.type.runtime_size == 8, "GenericArgReflection.intVal has unexpected size % instead of 8", it.type.runtime_size);
                case "boolVal";
                    assert(it.offset_in_bytes == 0, "GenericArgReflection.boolVal has unexpected offset % instead of 0", it.offset_in_bytes);
                    assert(it.type.runtime_size == 1, "GenericArgReflection.boolVal has unexpected size % instead of 1", it.type.runtime_size);
            }
        }
        assert(size_of(GenericArgReflection) == 8, "GenericArgReflection has size % instead of 8", size_of(GenericArgReflection));
    }

    assert(size_of(Attribute) == 1, "Attribute has size % instead of 1", size_of(Attribute));

    assert(size_of(TypeReflection) == 1, "TypeReflection has size % instead of 1", size_of(TypeReflection));

    assert(size_of(TypeLayoutReflection) == 1, "TypeLayoutReflection has size % instead of 1", size_of(TypeLayoutReflection));

    assert(size_of(Modifier) == 1, "Modifier has size % instead of 1", size_of(Modifier));

    assert(size_of(VariableReflection) == 1, "VariableReflection has size % instead of 1", size_of(VariableReflection));

    assert(size_of(VariableLayoutReflection) == 1, "VariableLayoutReflection has size % instead of 1", size_of(VariableLayoutReflection));

    assert(size_of(FunctionReflection) == 1, "FunctionReflection has size % instead of 1", size_of(FunctionReflection));

    assert(size_of(GenericReflection) == 1, "GenericReflection has size % instead of 1", size_of(GenericReflection));

    assert(size_of(EntryPointReflection) == 1, "EntryPointReflection has size % instead of 1", size_of(EntryPointReflection));

    assert(size_of(TypeParameterReflection) == 1, "TypeParameterReflection has size % instead of 1", size_of(TypeParameterReflection));

    assert(size_of(ShaderReflection) == 1, "ShaderReflection has size % instead of 1", size_of(ShaderReflection));

    {
        info := type_info(DeclReflection.IteratedList.Iterator);
        for info.members {
            if it.name == {
                case "parent";
                    assert(it.offset_in_bytes == 0, "DeclReflection.IteratedList.Iterator.parent has unexpected offset % instead of 0", it.offset_in_bytes);
                    assert(it.type.runtime_size == 8, "DeclReflection.IteratedList.Iterator.parent has unexpected size % instead of 8", it.type.runtime_size);
                case "count";
                    assert(it.offset_in_bytes == 8, "DeclReflection.IteratedList.Iterator.count has unexpected offset % instead of 8", it.offset_in_bytes);
                    assert(it.type.runtime_size == 4, "DeclReflection.IteratedList.Iterator.count has unexpected size % instead of 4", it.type.runtime_size);
                case "index";
                    assert(it.offset_in_bytes == 12, "DeclReflection.IteratedList.Iterator.index has unexpected offset % instead of 12", it.offset_in_bytes);
                    assert(it.type.runtime_size == 4, "DeclReflection.IteratedList.Iterator.index has unexpected size % instead of 4", it.type.runtime_size);
            }
        }
        assert(size_of(DeclReflection.IteratedList.Iterator) == 16, "DeclReflection.IteratedList.Iterator has size % instead of 16", size_of(DeclReflection.IteratedList.Iterator));
    }

    {
        info := type_info(DeclReflection.IteratedList);
        for info.members {
            if it.name == {
                case "count";
                    assert(it.offset_in_bytes == 0, "DeclReflection.IteratedList.count has unexpected offset % instead of 0", it.offset_in_bytes);
                    assert(it.type.runtime_size == 4, "DeclReflection.IteratedList.count has unexpected size % instead of 4", it.type.runtime_size);
                case "parent";
                    assert(it.offset_in_bytes == 8, "DeclReflection.IteratedList.parent has unexpected offset % instead of 8", it.offset_in_bytes);
                    assert(it.type.runtime_size == 8, "DeclReflection.IteratedList.parent has unexpected size % instead of 8", it.type.runtime_size);
            }
        }
        assert(size_of(DeclReflection.IteratedList) == 16, "DeclReflection.IteratedList has size % instead of 16", size_of(DeclReflection.IteratedList));
    }

    assert(size_of(DeclReflection) == 1, "DeclReflection has size % instead of 1", size_of(DeclReflection));

    assert(size_of(CompileCoreModuleFlag) == 1, "CompileCoreModuleFlag has size % instead of 1", size_of(CompileCoreModuleFlag));

    assert(size_of(IGlobalSession) == 8, "IGlobalSession has size % instead of 8", size_of(IGlobalSession));

    {
        info := type_info(TargetDesc);
        for info.members {
            if it.name == {
                case "structureSize";
                    assert(it.offset_in_bytes == 0, "TargetDesc.structureSize has unexpected offset % instead of 0", it.offset_in_bytes);
                    assert(it.type.runtime_size == 8, "TargetDesc.structureSize has unexpected size % instead of 8", it.type.runtime_size);
                case "format";
                    assert(it.offset_in_bytes == 8, "TargetDesc.format has unexpected offset % instead of 8", it.offset_in_bytes);
                    assert(it.type.runtime_size == 4, "TargetDesc.format has unexpected size % instead of 4", it.type.runtime_size);
                case "profile";
                    assert(it.offset_in_bytes == 12, "TargetDesc.profile has unexpected offset % instead of 12", it.offset_in_bytes);
                    assert(it.type.runtime_size == 4, "TargetDesc.profile has unexpected size % instead of 4", it.type.runtime_size);
                case "flags";
                    assert(it.offset_in_bytes == 16, "TargetDesc.flags has unexpected offset % instead of 16", it.offset_in_bytes);
                    assert(it.type.runtime_size == 4, "TargetDesc.flags has unexpected size % instead of 4", it.type.runtime_size);
                case "floatingPointMode";
                    assert(it.offset_in_bytes == 20, "TargetDesc.floatingPointMode has unexpected offset % instead of 20", it.offset_in_bytes);
                    assert(it.type.runtime_size == 4, "TargetDesc.floatingPointMode has unexpected size % instead of 4", it.type.runtime_size);
                case "lineDirectiveMode";
                    assert(it.offset_in_bytes == 24, "TargetDesc.lineDirectiveMode has unexpected offset % instead of 24", it.offset_in_bytes);
                    assert(it.type.runtime_size == 4, "TargetDesc.lineDirectiveMode has unexpected size % instead of 4", it.type.runtime_size);
                case "forceGLSLScalarBufferLayout";
                    assert(it.offset_in_bytes == 28, "TargetDesc.forceGLSLScalarBufferLayout has unexpected offset % instead of 28", it.offset_in_bytes);
                    assert(it.type.runtime_size == 1, "TargetDesc.forceGLSLScalarBufferLayout has unexpected size % instead of 1", it.type.runtime_size);
                case "compilerOptionEntries";
                    assert(it.offset_in_bytes == 32, "TargetDesc.compilerOptionEntries has unexpected offset % instead of 32", it.offset_in_bytes);
                    assert(it.type.runtime_size == 8, "TargetDesc.compilerOptionEntries has unexpected size % instead of 8", it.type.runtime_size);
                case "compilerOptionEntryCount";
                    assert(it.offset_in_bytes == 40, "TargetDesc.compilerOptionEntryCount has unexpected offset % instead of 40", it.offset_in_bytes);
                    assert(it.type.runtime_size == 4, "TargetDesc.compilerOptionEntryCount has unexpected size % instead of 4", it.type.runtime_size);
            }
        }
        assert(size_of(TargetDesc) == 48, "TargetDesc has size % instead of 48", size_of(TargetDesc));
    }

    {
        info := type_info(PreprocessorMacroDesc);
        for info.members {
            if it.name == {
                case "name";
                    assert(it.offset_in_bytes == 0, "PreprocessorMacroDesc.name has unexpected offset % instead of 0", it.offset_in_bytes);
                    assert(it.type.runtime_size == 8, "PreprocessorMacroDesc.name has unexpected size % instead of 8", it.type.runtime_size);
                case "value";
                    assert(it.offset_in_bytes == 8, "PreprocessorMacroDesc.value has unexpected offset % instead of 8", it.offset_in_bytes);
                    assert(it.type.runtime_size == 8, "PreprocessorMacroDesc.value has unexpected size % instead of 8", it.type.runtime_size);
            }
        }
        assert(size_of(PreprocessorMacroDesc) == 16, "PreprocessorMacroDesc has size % instead of 16", size_of(PreprocessorMacroDesc));
    }

    {
        info := type_info(SessionDesc);
        for info.members {
            if it.name == {
                case "structureSize";
                    assert(it.offset_in_bytes == 0, "SessionDesc.structureSize has unexpected offset % instead of 0", it.offset_in_bytes);
                    assert(it.type.runtime_size == 8, "SessionDesc.structureSize has unexpected size % instead of 8", it.type.runtime_size);
                case "targets";
                    assert(it.offset_in_bytes == 8, "SessionDesc.targets has unexpected offset % instead of 8", it.offset_in_bytes);
                    assert(it.type.runtime_size == 8, "SessionDesc.targets has unexpected size % instead of 8", it.type.runtime_size);
                case "targetCount";
                    assert(it.offset_in_bytes == 16, "SessionDesc.targetCount has unexpected offset % instead of 16", it.offset_in_bytes);
                    assert(it.type.runtime_size == 8, "SessionDesc.targetCount has unexpected size % instead of 8", it.type.runtime_size);
                case "flags";
                    assert(it.offset_in_bytes == 24, "SessionDesc.flags has unexpected offset % instead of 24", it.offset_in_bytes);
                    assert(it.type.runtime_size == 4, "SessionDesc.flags has unexpected size % instead of 4", it.type.runtime_size);
                case "defaultMatrixLayoutMode";
                    assert(it.offset_in_bytes == 28, "SessionDesc.defaultMatrixLayoutMode has unexpected offset % instead of 28", it.offset_in_bytes);
                    assert(it.type.runtime_size == 4, "SessionDesc.defaultMatrixLayoutMode has unexpected size % instead of 4", it.type.runtime_size);
                case "searchPaths";
                    assert(it.offset_in_bytes == 32, "SessionDesc.searchPaths has unexpected offset % instead of 32", it.offset_in_bytes);
                    assert(it.type.runtime_size == 8, "SessionDesc.searchPaths has unexpected size % instead of 8", it.type.runtime_size);
                case "searchPathCount";
                    assert(it.offset_in_bytes == 40, "SessionDesc.searchPathCount has unexpected offset % instead of 40", it.offset_in_bytes);
                    assert(it.type.runtime_size == 8, "SessionDesc.searchPathCount has unexpected size % instead of 8", it.type.runtime_size);
                case "preprocessorMacros";
                    assert(it.offset_in_bytes == 48, "SessionDesc.preprocessorMacros has unexpected offset % instead of 48", it.offset_in_bytes);
                    assert(it.type.runtime_size == 8, "SessionDesc.preprocessorMacros has unexpected size % instead of 8", it.type.runtime_size);
                case "preprocessorMacroCount";
                    assert(it.offset_in_bytes == 56, "SessionDesc.preprocessorMacroCount has unexpected offset % instead of 56", it.offset_in_bytes);
                    assert(it.type.runtime_size == 8, "SessionDesc.preprocessorMacroCount has unexpected size % instead of 8", it.type.runtime_size);
                case "fileSystem";
                    assert(it.offset_in_bytes == 64, "SessionDesc.fileSystem has unexpected offset % instead of 64", it.offset_in_bytes);
                    assert(it.type.runtime_size == 8, "SessionDesc.fileSystem has unexpected size % instead of 8", it.type.runtime_size);
                case "enableEffectAnnotations";
                    assert(it.offset_in_bytes == 72, "SessionDesc.enableEffectAnnotations has unexpected offset % instead of 72", it.offset_in_bytes);
                    assert(it.type.runtime_size == 1, "SessionDesc.enableEffectAnnotations has unexpected size % instead of 1", it.type.runtime_size);
                case "allowGLSLSyntax";
                    assert(it.offset_in_bytes == 73, "SessionDesc.allowGLSLSyntax has unexpected offset % instead of 73", it.offset_in_bytes);
                    assert(it.type.runtime_size == 1, "SessionDesc.allowGLSLSyntax has unexpected size % instead of 1", it.type.runtime_size);
                case "compilerOptionEntries";
                    assert(it.offset_in_bytes == 80, "SessionDesc.compilerOptionEntries has unexpected offset % instead of 80", it.offset_in_bytes);
                    assert(it.type.runtime_size == 8, "SessionDesc.compilerOptionEntries has unexpected size % instead of 8", it.type.runtime_size);
                case "compilerOptionEntryCount";
                    assert(it.offset_in_bytes == 88, "SessionDesc.compilerOptionEntryCount has unexpected offset % instead of 88", it.offset_in_bytes);
                    assert(it.type.runtime_size == 4, "SessionDesc.compilerOptionEntryCount has unexpected size % instead of 4", it.type.runtime_size);
                case "skipSPIRVValidation";
                    assert(it.offset_in_bytes == 92, "SessionDesc.skipSPIRVValidation has unexpected offset % instead of 92", it.offset_in_bytes);
                    assert(it.type.runtime_size == 1, "SessionDesc.skipSPIRVValidation has unexpected size % instead of 1", it.type.runtime_size);
            }
        }
        assert(size_of(SessionDesc) == 96, "SessionDesc has size % instead of 96", size_of(SessionDesc));
    }

    assert(size_of(ISession) == 8, "ISession has size % instead of 8", size_of(ISession));

    assert(size_of(IMetadata) == 8, "IMetadata has size % instead of 8", size_of(IMetadata));

    assert(size_of(ICompileResult) == 8, "ICompileResult has size % instead of 8", size_of(ICompileResult));

    assert(size_of(IComponentType) == 8, "IComponentType has size % instead of 8", size_of(IComponentType));

    assert(size_of(IEntryPoint) == 8, "IEntryPoint has size % instead of 8", size_of(IEntryPoint));

    assert(size_of(ITypeConformance) == 8, "ITypeConformance has size % instead of 8", size_of(ITypeConformance));

    assert(size_of(IComponentType2) == 8, "IComponentType2 has size % instead of 8", size_of(IComponentType2));

    assert(size_of(IModule) == 8, "IModule has size % instead of 8", size_of(IModule));

    assert(size_of(IModulePrecompileService_Experimental) == 8, "IModulePrecompileService_Experimental has size % instead of 8", size_of(IModulePrecompileService_Experimental));

    {
        info := type_info(SpecializationArg);
        for info.members {
            if it.name == {
                case "kind";
                    assert(it.offset_in_bytes == 0, "SpecializationArg.kind has unexpected offset % instead of 0", it.offset_in_bytes);
                    assert(it.type.runtime_size == 4, "SpecializationArg.kind has unexpected size % instead of 4", it.type.runtime_size);
            }
        }
        assert(size_of(SpecializationArg) == 16, "SpecializationArg has size % instead of 16", size_of(SpecializationArg));
    }

    {
        info := type_info(VMExecOperand);
        for info.members {
            if it.name == {
                case "section";
                    assert(it.offset_in_bytes == 0, "VMExecOperand.section has unexpected offset % instead of 0", it.offset_in_bytes);
                    assert(it.type.runtime_size == 8, "VMExecOperand.section has unexpected size % instead of 8", it.type.runtime_size);
                case "__bitfield";
                    assert(it.offset_in_bytes == 8, "VMExecOperand.__bitfield has unexpected offset % instead of 8", it.offset_in_bytes);
                    assert(it.type.runtime_size == 4, "VMExecOperand.__bitfield has unexpected size % instead of 4", it.type.runtime_size);
                case "offset";
                    assert(it.offset_in_bytes == 12, "VMExecOperand.offset has unexpected offset % instead of 12", it.offset_in_bytes);
                    assert(it.type.runtime_size == 4, "VMExecOperand.offset has unexpected size % instead of 4", it.type.runtime_size);
            }
        }
        assert(size_of(VMExecOperand) == 16, "VMExecOperand has size % instead of 16", size_of(VMExecOperand));
    }

    {
        info := type_info(VMExecInstHeader);
        for info.members {
            if it.name == {
                case "functionPtr";
                    assert(it.offset_in_bytes == 0, "VMExecInstHeader.functionPtr has unexpected offset % instead of 0", it.offset_in_bytes);
                    assert(it.type.runtime_size == 8, "VMExecInstHeader.functionPtr has unexpected size % instead of 8", it.type.runtime_size);
                case "opcodeExtension";
                    assert(it.offset_in_bytes == 8, "VMExecInstHeader.opcodeExtension has unexpected offset % instead of 8", it.offset_in_bytes);
                    assert(it.type.runtime_size == 4, "VMExecInstHeader.opcodeExtension has unexpected size % instead of 4", it.type.runtime_size);
                case "operandCount";
                    assert(it.offset_in_bytes == 12, "VMExecInstHeader.operandCount has unexpected offset % instead of 12", it.offset_in_bytes);
                    assert(it.type.runtime_size == 4, "VMExecInstHeader.operandCount has unexpected size % instead of 4", it.type.runtime_size);
            }
        }
        assert(size_of(VMExecInstHeader) == 16, "VMExecInstHeader has size % instead of 16", size_of(VMExecInstHeader));
    }

    {
        info := type_info(ByteCodeFuncInfo);
        for info.members {
            if it.name == {
                case "parameterCount";
                    assert(it.offset_in_bytes == 0, "ByteCodeFuncInfo.parameterCount has unexpected offset % instead of 0", it.offset_in_bytes);
                    assert(it.type.runtime_size == 4, "ByteCodeFuncInfo.parameterCount has unexpected size % instead of 4", it.type.runtime_size);
                case "returnValueSize";
                    assert(it.offset_in_bytes == 4, "ByteCodeFuncInfo.returnValueSize has unexpected offset % instead of 4", it.offset_in_bytes);
                    assert(it.type.runtime_size == 4, "ByteCodeFuncInfo.returnValueSize has unexpected size % instead of 4", it.type.runtime_size);
            }
        }
        assert(size_of(ByteCodeFuncInfo) == 8, "ByteCodeFuncInfo has size % instead of 8", size_of(ByteCodeFuncInfo));
    }

    {
        info := type_info(ByteCodeRunnerDesc);
        for info.members {
            if it.name == {
                case "structSize";
                    assert(it.offset_in_bytes == 0, "ByteCodeRunnerDesc.structSize has unexpected offset % instead of 0", it.offset_in_bytes);
                    assert(it.type.runtime_size == 8, "ByteCodeRunnerDesc.structSize has unexpected size % instead of 8", it.type.runtime_size);
            }
        }
        assert(size_of(ByteCodeRunnerDesc) == 8, "ByteCodeRunnerDesc has size % instead of 8", size_of(ByteCodeRunnerDesc));
    }

    assert(size_of(IByteCodeRunner) == 8, "IByteCodeRunner has size % instead of 8", size_of(IByteCodeRunner));

    {
        info := type_info(SlangUUID);
        for info.members {
            if it.name == {
                case "data1";
                    assert(it.offset_in_bytes == 0, "SlangUUID.data1 has unexpected offset % instead of 0", it.offset_in_bytes);
                    assert(it.type.runtime_size == 4, "SlangUUID.data1 has unexpected size % instead of 4", it.type.runtime_size);
                case "data2";
                    assert(it.offset_in_bytes == 4, "SlangUUID.data2 has unexpected offset % instead of 4", it.offset_in_bytes);
                    assert(it.type.runtime_size == 2, "SlangUUID.data2 has unexpected size % instead of 2", it.type.runtime_size);
                case "data3";
                    assert(it.offset_in_bytes == 6, "SlangUUID.data3 has unexpected offset % instead of 6", it.offset_in_bytes);
                    assert(it.type.runtime_size == 2, "SlangUUID.data3 has unexpected size % instead of 2", it.type.runtime_size);
                case "data4";
                    assert(it.offset_in_bytes == 8, "SlangUUID.data4 has unexpected offset % instead of 8", it.offset_in_bytes);
                    assert(it.type.runtime_size == 8, "SlangUUID.data4 has unexpected size % instead of 8", it.type.runtime_size);
            }
        }
        assert(size_of(SlangUUID) == 16, "SlangUUID has size % instead of 16", size_of(SlangUUID));
    }

    assert(size_of(ISlangUnknown) == 8, "ISlangUnknown has size % instead of 8", size_of(ISlangUnknown));

    assert(size_of(ISlangCastable) == 8, "ISlangCastable has size % instead of 8", size_of(ISlangCastable));

    assert(size_of(ISlangClonable) == 8, "ISlangClonable has size % instead of 8", size_of(ISlangClonable));

    assert(size_of(ISlangBlob) == 8, "ISlangBlob has size % instead of 8", size_of(ISlangBlob));

    {
        info := type_info(SlangTerminatedChars);
        for info.members {
            if it.name == {
                case "chars";
                    assert(it.offset_in_bytes == 0, "SlangTerminatedChars.chars has unexpected offset % instead of 0", it.offset_in_bytes);
                    assert(it.type.runtime_size == 1, "SlangTerminatedChars.chars has unexpected size % instead of 1", it.type.runtime_size);
            }
        }
        assert(size_of(SlangTerminatedChars) == 1, "SlangTerminatedChars has size % instead of 1", size_of(SlangTerminatedChars));
    }

    assert(size_of(ISlangFileSystem) == 8, "ISlangFileSystem has size % instead of 8", size_of(ISlangFileSystem));

    assert(size_of(ISlangSharedLibrary_Dep1) == 8, "ISlangSharedLibrary_Dep1 has size % instead of 8", size_of(ISlangSharedLibrary_Dep1));

    assert(size_of(ISlangSharedLibrary) == 8, "ISlangSharedLibrary has size % instead of 8", size_of(ISlangSharedLibrary));

    assert(size_of(ISlangSharedLibraryLoader) == 8, "ISlangSharedLibraryLoader has size % instead of 8", size_of(ISlangSharedLibraryLoader));

    assert(size_of(ISlangFileSystemExt) == 8, "ISlangFileSystemExt has size % instead of 8", size_of(ISlangFileSystemExt));

    assert(size_of(ISlangMutableFileSystem) == 8, "ISlangMutableFileSystem has size % instead of 8", size_of(ISlangMutableFileSystem));

    assert(size_of(ISlangWriter) == 8, "ISlangWriter has size % instead of 8", size_of(ISlangWriter));

    assert(size_of(ISlangProfiler) == 8, "ISlangProfiler has size % instead of 8", size_of(ISlangProfiler));

    {
        info := type_info(SlangReflectionGenericArg);
        for info.members {
            if it.name == {
                case "typeVal";
                    assert(it.offset_in_bytes == 0, "SlangReflectionGenericArg.typeVal has unexpected offset % instead of 0", it.offset_in_bytes);
                    assert(it.type.runtime_size == 8, "SlangReflectionGenericArg.typeVal has unexpected size % instead of 8", it.type.runtime_size);
                case "intVal";
                    assert(it.offset_in_bytes == 0, "SlangReflectionGenericArg.intVal has unexpected offset % instead of 0", it.offset_in_bytes);
                    assert(it.type.runtime_size == 8, "SlangReflectionGenericArg.intVal has unexpected size % instead of 8", it.type.runtime_size);
                case "boolVal";
                    assert(it.offset_in_bytes == 0, "SlangReflectionGenericArg.boolVal has unexpected offset % instead of 0", it.offset_in_bytes);
                    assert(it.type.runtime_size == 1, "SlangReflectionGenericArg.boolVal has unexpected size % instead of 1", it.type.runtime_size);
            }
        }
        assert(size_of(SlangReflectionGenericArg) == 8, "SlangReflectionGenericArg has size % instead of 8", size_of(SlangReflectionGenericArg));
    }

    {
        info := type_info(SlangGlobalSessionDesc);
        for info.members {
            if it.name == {
                case "structureSize";
                    assert(it.offset_in_bytes == 0, "SlangGlobalSessionDesc.structureSize has unexpected offset % instead of 0", it.offset_in_bytes);
                    assert(it.type.runtime_size == 4, "SlangGlobalSessionDesc.structureSize has unexpected size % instead of 4", it.type.runtime_size);
                case "apiVersion";
                    assert(it.offset_in_bytes == 4, "SlangGlobalSessionDesc.apiVersion has unexpected offset % instead of 4", it.offset_in_bytes);
                    assert(it.type.runtime_size == 4, "SlangGlobalSessionDesc.apiVersion has unexpected size % instead of 4", it.type.runtime_size);
                case "minLanguageVersion";
                    assert(it.offset_in_bytes == 8, "SlangGlobalSessionDesc.minLanguageVersion has unexpected offset % instead of 8", it.offset_in_bytes);
                    assert(it.type.runtime_size == 4, "SlangGlobalSessionDesc.minLanguageVersion has unexpected size % instead of 4", it.type.runtime_size);
                case "enableGLSL";
                    assert(it.offset_in_bytes == 12, "SlangGlobalSessionDesc.enableGLSL has unexpected offset % instead of 12", it.offset_in_bytes);
                    assert(it.type.runtime_size == 1, "SlangGlobalSessionDesc.enableGLSL has unexpected size % instead of 1", it.type.runtime_size);
                case "reserved";
                    assert(it.offset_in_bytes == 16, "SlangGlobalSessionDesc.reserved has unexpected offset % instead of 16", it.offset_in_bytes);
                    assert(it.type.runtime_size == 64, "SlangGlobalSessionDesc.reserved has unexpected size % instead of 64", it.type.runtime_size);
            }
        }
        assert(size_of(SlangGlobalSessionDesc) == 80, "SlangGlobalSessionDesc has size % instead of 80", size_of(SlangGlobalSessionDesc));
    }
}

